
<html lang=fr>
	<style>
		dl {margin-left: 2ex; }
		pre {margin-left: 2ex; }
	</style>
	
	<head>
		<meta http-equiv="PICS-Label" content='(PICS-1.1 "http://www.rsac.org/ratingsv01.html" l gen false r (n 0 s 0 v 0 l 0))'>
		<meta name="generator" content="notepad.exe">
		<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
		<META HTTP-EQUIV="keywords" CONTENT="irc, rfc, rfc1459, internet, chat">
		<meta name="robots" content="index, follow">
		<link rel=stylesheet href=../global.css>
		<title>RFC 1459 - Français</title>
	</head>
	
	<body>
	<div class=top>
		<span class=nav>
		<a href=/>nirgal.com</a> &gt; <a href=.>irc</a> &gt; <span class=here>RFC1459</span>
		</span>
	
		<h1>RFC1459 (French)</h1>
	</div><div class=main>
	
	<div class=box>
	<table border=0 width=80% align=center>
	<tr>
		<td>Groupe de Travail Réseau</td>
		<td align=right>J. Oikarinen</td>
	</tr>
	<tr>
		<td>Requête pour commentaires: 1459
		<td align=right>D. Reed</td>
	</tr>
	<tr>
		<td></td>
		<td align=right>Mai 1993</td>
	</tr>
	</table>
	
	<p>
	
	<center><h1>Protocole de discussions relayées par internet (IRC)</h1></center>
	
	<h3>Statut de ce mémo</h3>
	
	<p>Ce mémo définit un protocole expérimental
	pour la communauté internet. Des discussions et suggestions
	d'améliorations sont attendues. Veuillez vous référer
	à la version courante de "IAB Official Protocol Standards"
	pour connaître l'état de standardisation et le statut
	de ce protocole. La distribution de ce mémo n'est pas limitée.
	
	<h3>Résumé</h3>
	
	<p>Le protocole IRC a été développé
	au cours des 4 dernières années. Il a été
	initialement implémenté pour permettre aux utilisateurs
	d'un BBS de discuter entre eux. Maintenant, il est utilisé
	sur un réseau mondial de serveurs et de clients, et a du
	mal à gérer sa croissance. Au cours des deux dernières
	années, le nombre moyen d'utilisateurs connectés
	au réseau IRC principal a été multiplié
	par 10.<p>
	
	Le protocole IRC est un protocole en mode texte, dont
	le client le plus simple est n'importe quel programme TCP capable
	de se connecter à un serveur.<p>
	
	<h3>Table des matières</h3>
	<pre>
	   <a href="#1">1.  Introduction</a>
		  <a href="#11">1.1  Serveurs</a>
		  <a href="#12">1.2  Clients</a>
			 <a href="#121">1.2.1 Opérateurs</a>
		  <a href="#13">1.3 Canaux</a>
		  <a href="#131">1.3.1 Opérateurs de canaux</a>
	   <a href="#2">2. Spécification IRC</a>
		  <a href="#21">2.1 Aperçu</a>
		  <a href="#22">2.2 Les jeux de caractères</a>
		  <a href="#23">2.3 Messages</a>
			 <a href="#231">2.3.1 Le format de message en 'pseudo' BNF</a>
		  <a href="#24">2.4 Réponses numériques</a>
	   <a href="#3">3. Concepts IRC</a>
		  <a href="#31">3.1 Communication un à un</a>
		  <a href="#32">3.2 Un à plusieurs</a>
			 <a href="#321">3.2.1 À une liste</a>
			 <a href="#322">3.2.2 À un groupe (canal)</a>
			 <a href="#323">3.2.3 À un masque d'hôte/de serveur</a>
		  <a href="#33">3.3 Un à tous</a>
			 <a href="#331">3.3.1 Client à client</a>
			 <a href="#332">3.3.2 Client à serveur</a>
			 <a href="#333">3.3.3 Serveur à serveur</a>
	   <a href="#4">4. Détails des messages</a>
		  <a href="#41">4.1 Etablissement de connexion</a>
			 <a href="#411">4.1.1 Message PASSWORD </a>
			 <a href="#412">4.1.2 Message NICK</a>
			 <a href="#413">4.1.3 Message USER</a>
			 <a href="#414">4.1.4 Message SERVER</a>
			 <a href="#415">4.1.5 Message OPER</a>
			 <a href="#416">4.1.6 Message QUIT</a>
			 <a href="#417">4.1.7 Message SQUIT</a>
		  <a href="#42">4.2 Opérations sur les canaux</a>
			 <a href="#421">4.2.1 Message JOIN</a>
			 <a href="#422">4.2.2 Message PART</a>
			 <a href="#423">4.2.3 Message MODE</a>
				<a href="#4231">4.2.3.1 Les modes des canaux</a>
				<a href="#4232">4.2.3.2 Les modes des utilisateurs</a>
			 <a href="#424">4.2.4 Message TOPIC</a>
			 <a href="#425">4.2.5 Message NAMES</a>
			 <a href="#426">4.2.6 Message LIST</a>
			 <a href="#427">4.2.7 Message INVITE</a>
			 <a href="#428">4.2.8 Message KICK</a>
		  <a href="#43">4.3 Requêtes et commandes des serveurs</a>
			 <a href="#431">4.3.1 Message VERSION</a>
			 <a href="#432">4.3.2 Message STATS</a>
			 <a href="#433">4.3.3 Message LINKS</a>
			 <a href="#434">4.3.4 Message TIME</a>
			 <a href="#435">4.3.5 Message CONNECT</a>
			 <a href="#436">4.3.6 Message TRACE</a>
			 <a href="#437">4.3.7 Message ADMIN</a>
			 <a href="#438">4.3.8 Message INFO</a>
		  <a href="#44">4.4 Envoi de messages</a>
			 <a href="#441">4.4.1 Messages privés</a>
			 <a href="#442">4.4.2 NOTICE</a>
		  <a href="#45">4.5 Requêtes basées sur les utilisateurs</a>
			 <a href="#451">4.5.1 Message WHO</a>
			 <a href="#452">4.5.2 Message WHOIS</a>
			 <a href="#453">4.5.3 Message WHOWAS</a>
		  <a href="#46">4.6 Messages divers</a>
			 <a href="#461">4.6.1 Message KILL </a>
			 <a href="#462">4.6.2 Message PING</a>
			 <a href="#463">4.6.3 Message PONG</a>
			 <a href="#464">4.6.4 Message ERROR</a>
	   <a href="#5">5. Messages optionnels</a>
		  <a href="#51">5.1 Message AWAY</a>
		  <a href="#52">5.2 Commande REHASH</a>
		  <a href="#53">5.3 Commande RESTART</a>
		  <a href="#54">5.4 Message SUMMON</a>
		  <a href="#55">5.5 Message USER</a>
		  <a href="#56">5.6 Commande OPERWALL</a>
		  <a href="#57">5.7 Message USERHOST</a>
		  <a href="#58">5.8 Message ISON</a>
	   <a href="#6">6. Réponses </a>
		  <a href="#61">6.1 Réponses d'erreur</a>
		  <a href="#62">6.2 Réponses aux commandes</a>
		  <a href="#63">6.3 Nombres réservés</a>
	   <a href="#7">7. Authentification des clients et serveurs</a>
	   <a href="#8">8. Implémentations actuelles</a>
		  <a href="#81">8.1 Protocole Réseau: TCP</a>
			 <a href="#811">8.1.1 Support des sockets Unix</a>
		  <a href="#82">8.2 Traitement des commandes</a>
		  <a href="#83">8.3 Distribution de messages</a>
		  <a href="#84">8.4 La vie d'une connexion</a>
		  <a href="#85">8.5 Établissement d'une connexion serveur à client</a>
		  <a href="#86">8.6 Établissement d'une connexion serveur/serveur</a>
			 <a href="#861">8.6.1 Échange des informations d'état des serveurs à la connexion</a>
		  <a href="#87">8.7 Terminaison des connexions serveur/client</a>
		  <a href="#88">8.8 Terminaison des connexions serveur/serveur</a>
		  <a href="#9">8.9 Suivi des changements de pseudonymes</a>
		  <a href="#8_10">8.10 Contrôle d'inondation des clients</a>
		  <a href="#8_11">8.11 Recherches non bloquantes</a>
			 <a href="#8_11_1">8.11.1 Recherche du nom d'hôte (DNS)</a>
			 <a href="#8_11_2">8.11.2 Recherche du nom d'utilisateur (IDENT)</a>
		  <a href="#8_12">8.12 Fichier de configuration</a>
			 <a href="#8_12_1">8.12.1 Autorisation des connexions de clients</a>
			 <a href="#8_12_2">8.12.2 Opérateurs</a>
			 <a href="#8_12_3">8.12.3 Autorisation des connexions de serveurs</a>
			 <a href="#8_12_4">8.12.4 Admin</a>
		  <a href="#8_13">8.13 Appartenance à un canal.</a>
	   <a href="#9">9. Problèmes actuels</a>
		  <a href="#91">9.1 Localisation</a>
		  <a href="#92">9.2 Identifiants</a>
			 <a href="#921">9.2.1 Pseudonymes</a>
			 <a href="#922">9.2.2 Canaux</a>
			 <a href="#923">9.2.3 Serveurs</a>
		  <a href="#93">9.3 Algorithmes</a>
	   <a href="#_10">10. Support actuel et disponibilité</a>
	   <a href="#_11">11. Considérations de sécurité</a>
	   <a href="#_12">12. Adresses des auteurs</a>
	</pre>
	
	<h1><a name="1">1.</a> Introduction</h1>
	
	<p>Le protocole IRC (Internet Relay Chat) a été
	conçu pendant de nombreuses années pour l'usage
	de conférences en mode texte. Ce document décrit
	le protocole IRC actuel.<p>
	
	Le protocole IRC a été développé
	sur des systèmes utilisant le protocole réseau TCP/IP,
	bien qu'il n'y ait pas de raison que cela reste la seule sphère
	dans laquelle il opère.<p>
	
	L'IRC, en lui-même, est un système de
	téléconférence qui (grâce à
	l'utilisation d'un modèle client/serveur) est adapté
	à une exécution sur de nombreuses machines, de façon
	distribuée. Une configuration type comprend un processus
	unique (le serveur) qui fournit un point d'accès pour les
	clients (ou d'autres serveurs), et qui traite l'acheminement /
	le multiplexage requis de messages, ainsi que d'autres fonctions.
	
	<h2><a name="11">1.1</a> Serveurs</h2>
	
	<p>Le serveur est la colonne vertébrale de l'IRC.
	Il fournit un point auquel les clients peuvent se connecter
	pour parler entre eux, et un point auquel les autres serveurs
	peuvent se connecter, formant un réseau IRC. La seule configuration
	de réseau autorisée est celle d'un arbre [voir Fig.
	1] où chaque serveur agit comme un noeud central pour la
	partie du réseau qu'il voit.<br>
	
	<center>
	<pre>
							 [ Serveur 15 ]  [ Serveur 13 ] [ Serveur 14]
									 /                \         /
									/                  \       /
			[ Serveur 11 ] ------ [ Serveur 1 ]       [ Serveur 12]
								  /        \          /
								 /          \        /
					  [ Serveur 2 ]          [ Serveur 3 ]
						/       \                      \
					   /         \                      \
			   [ Serveur 4 ]    [ Serveur 5 ]         [ Serveur 6 ]
				/    |    \                           /
			   /     |     \                         /
			  /      |      \____                   /
			 /       |           \                 /
	[ Serveur 7 ] [ Serveur 8 ] [ Serveur 9 ]   [ Serveur 10 ]
	
									  :
								   [ etc. ]
									  :
	[ Fig. 1. Format d'un réseau de serveur IRC ]
	</pre>
	</center>
	
	<h2><a name="12">1.2</a> Clients</h2>
	
	<p>Un client est tout ce qui se connecte à un
	serveur et qui n'est pas un autre serveur. Chaque client est différencié
	des autres clients par un pseudonyme unique ayant une longueur
	maximale de neuf (9) caractères. Voir dans les règles
	de grammaire du protocole ce qui est autorisé et ce
	qui ne l'est pas dans un pseudonyme. En plus du pseudonyme,
	tous les serveurs doivent connaître les informations suivantes
	sur tous les clients : le vrai nom de l'hôte sur lequel
	le client est exécuté, le nom de l'utilisateur du
	client sur cet hôte, et le serveur auquel le client est
	connecté.<p>
	
	<h3><a name="121">1.2.1</a> Opérateurs</h3>
	
	<p>Pour permettre de maintenir un niveau d'ordre raisonnable
	dans un réseau IRC, une catégorie de clients spéciale
	(les opérateurs) est autorisée à exécuter
	des fonctions de maintenance générale sur le réseau.
	Bien que les pouvoirs donnés aux opérateurs puissent
	être considérés comme 'dangereux', ils sont
	néanmoins indispensables. Les opérateurs doivent
	être capables de faire certaines tâches de base, telles
	que la déconnexion et la reconnexion de serveurs, ce
	qui est nécessaire pour prévenir les problèmes
	à long terme de mauvais routage réseau. Étant donnée
	cette nécessité, le protocole décrit ici
	n'autorise que les opérateurs à effectuer ces fonctions.
	Voir les section <a href="#417">4.1.7</a> (SQUIT) et
	<a href="#435">4.3.5</a> (CONNECT).<p>
	
	Un pouvoir plus controversé des opérateurs
	est la possibilité de retirer par la force un utilisateur
	connecté au réseau, c'est à dire que les
	opérateurs peuvent clore une connexion entre un client
	et un serveur. La justification à cela est délicate
	puisque son abus est à la fois destructif et agaçant.
	Pour plus de détails concernant ce type d'actions, voir
	la section <a href="#461">4.6.1</a> (KILL).<p>
	
	<h2><a name="13">1.3</a>  Les canaux </h2>
	
	<p>Un canal est un groupe nommé d'un ou plusieurs
	clients qui recevront tous les messages adressés à
	ce canal. Les canaux sont créés implicitement quand
	le premier client y accède, et le canal disparaît
	lorsque le dernier client le quitte. Tant qu'un canal existe,
	tous les clients peuvent y accéder en utilisant le nom
	du canal.<p>
	
	Les noms de canaux sont des chaînes de caractères
	(commençant par un caractère '&amp;' ou '#') d'une
	longueur maximale de 200 caractères. En dehors du fait
	que le premier caractère doive être un '&amp;' ou
	un '#', la seule restriction sur le nom d'un canal est qu'il ne
	peut pas contenir d'espace (' '), de contrôle G (^G ou ASCII
	7), ou de virgule (',' qui est utilisée comme séparateur
	de liste dans le protocole).<p>
	
	Il y a deux types de canaux autorisés par
	ce protocole. L'un est un canal distribué, qui est connu
	de tous les serveurs connectés au réseau. Ces canaux
	commencent par un '#'. L'autre type de canal, reconnaissable à
	leur nom qui commence par un '&amp;', est marqué comme
	n'étant accessible qu'aux clients du serveur où
	le canal existe. En plus de ces deux types, il existe différents
	modes de canaux, permettant de modifier leur comportement individuel.
	Voir la section <a href="#423">4.2.3</a> (commande MODE) pour avoir plus
	de détails à ce sujet.
	
	<p>
	Pour créer un nouveau canal, ou pour faire
	partie d'un canal existant, un utilisateur doit accéder
	au canal. Si le canal n'existe pas avant l'accès, le canal
	est créé et l'utilisateur créateur devient
	opérateur de canal. Si le canal existait déjà
	au moment de l'accès, l'autorisation ou non d'accès
	dépend du mode du canal. Par exemple, si le canal est en
	"invités uniquement" (+i), vous ne pourrez joindre
	le canal que si vous êtes invité. Le protocole spécifie
	qu'un utilisateur peut être membre de plusieurs canaux à
	la fois, mais une limite de dix (10) canaux est recommandée
	comme étant amplement suffisante aussi bien pour les utilisateurs
	novices que pour les experts. Voir la section <a href="#8_13">8.13</a> pour
	plus d'informations à ce sujet.
	
	<p>
	Si le réseau IRC devient disjoint en raison
	d'une division entre deux serveurs, le canal, de chaque côté,
	est composé des clients qui sont connectés
	aux serveurs du côté respectif de la division, et ils
	disparaissent de l'autre côté de la division. Lorsque
	la division est réparée, les serveurs se reconnectant se
	communiquent entre eux qui, d'après eux, est dans chaque
	canal, et le mode de ce canal. Si le canal existe des deux côtés,
	les accès et les modes sont interprétés de
	façon inclusive pour que les deux côtés de
	la nouvelle connexion soient d'accord sur quels clients sont
	dans quels canaux et quels modes ont les canaux.
	
	<h3><a name="131">1.3.1</a>  Les opérateurs de canaux</h3>
	
	<p>Les opérateurs de canaux (aussi appelés
	"chanop") sur un canal donné, sont considérés
	comme étant propriétaires du "canal".
	A ce titre, les opérateurs de canaux sont dotés
	de certains pouvoirs qui leur permettent de garder le contrôle
	et une forme de salubrité à leur canal. En tant que propriétaire
	d'un canal, un opérateur de canal n'est pas tenu d'avoir
	de raisons pour agir, toutefois si leurs actions sont généralement
	antisociales ou abusives, il pourrait être raisonable de
	demander à un opérateur IRC d'intervenir, ou pour les utilisateurs
	de simplement partir et aller ailleurs former leur propre
	canal.
	
	<p>
	Les commandes réservées aux opérateurs
	de canaux sont :<br>
	
	KICK - Éjecte un client d'un canal<br>
	MODE - Change le mode d'un canal<br>
	INVITE - Invite un client dans un canal à
	accès sur invitation (mode +i)<br>
	TOPIC - Change le titre du canal, dans un canal en
	mode +t<br>
	
	<p>
	Un opérateur de canal est identifié
	par un symbole '@' devant son pseudonyme à chaque fois
	qu'il est utilisé en association avec le canal (c'est à
	dire lors des réponses aux commandes NAMES, WHO et WHOIS)
	
	
	<h1><a name="2">2.</a> La spécification IRC</h1>
	
	<h2><a name="21">2.1</a>  Aperçu</h2>
	
	<p>Le protocole décrit ici vaut aussi bien pour
	les connexions des serveurs que pour celles des clients. Néanmoins,
	il y a plus de restrictions sur les connexions des clients (qui
	sont considérées comme plus douteuses) que sur les connexions
	des serveurs.
	
	
	<h2><a name="22">2.2</a>  Les jeux de caractères</h2>
	
	<p>Aucun jeu de caractères n'est imposé.
	Le protocole est basé sur un jeu de caractères de
	huit (8) bits, qui forment un octet ; cependant, certains codes
	sont utilisés en tant que codes de contrôle, et agissent
	comme délimiteurs de messages.
	<p>
	Indépendamment du fait qu'il s'agisse d'un
	protocole 8 bits, les délimiteurs et les mots-clés
	sont tels que le protocole est utilisable d'un terminal US-ASCII
	et d'une connexion telnet.
	<p>
	Étant donnée l'origine scandinave de l'IRC,
	les caractères {}| sont considérés comme
	étant respectivement les équivalents en minuscules
	des caractères []\. Ceci est particulièrement important
	pour déterminer l'équivalence de deux pseudonymes.
	
	<h2><a name="23">2.3</a> Messages</h2>
	
	<p>Les serveurs et les clients s'envoient chacun des
	messages qui peuvent ou non générer une réponse.
	Si le message contient une commande valide, comme il est décrit
	dans les sections suivantes, le client devrait s'attendre à
	une réponse comme spécifié, mais il n'est
	pas conseillé d'attendre éternellement une réponse.
	La communication de client à serveur, et de serveur à
	serveur est essentiellement de nature asynchrone.
	<p>
	Chaque message IRC peut contenir jusqu'à trois
	parties : le préfixe (optionnel), la commande, et les paramètres
	de la commande (il peut y en avoir jusqu'à 15). Le préfixe,
	la commande, et tous les paramètres sont séparés
	par un (ou plusieurs) caractère(s) ASCII espace (0x20).
	<p>
	La présence d'un préfixe est indiquée
	par un simple caractère ASCII deux-points (':', 0x3b),
	qui doit être le premier caractère du message. Il
	ne doit pas y avoir de trou (d'espace blanc) entre les deux-points
	et le préfixe. Le préfixe est utilisé pour
	indiquer la véritable origine du message. S'il n'y a pas
	de préfixe, le message est considéré comme
	ayant pour origine la connexion de laquelle il est issu. Les
	clients ne doivent pas utiliser de préfixe lorsqu'ils envoient
	un message d'eux-mêmes. S'il utilise un préfixe,
	le seul valable est le pseudonyme associé au client. Si
	la source identifiée par le préfixe n'est pas trouvée
	dans la base de données interne du serveur, ou si la source
	est enregistrée avec une liaison différente de celle
	avec laquelle le message est arrivé, le serveur doit ignorer
	le message en silence.
	<p>
	La commande doit être soit une commande
	IRC valide, soit un nombre de trois (3) chiffres représentés
	en texte ASCII.
	<p>
	Les messages IRC sont toujours des lignes de caractères
	terminés par une paire CR-LF (retour chariot - saut de
	ligne), et ces messages ne doivent pas dépasser 512 caractères
	de long, en comptant tous les caractères y compris le CR-LF
	final. Donc, il y a un maximum de 510 caractères autorisés
	pour la commande et ses paramètres. Il n'y a pas de système
	permettant une ligne de continuation de message. Voir la section
	<a href="#7">7</a> pour les implémentations actuelles.
	
	<h3><a name="231">2.3.1</a>  Le format de message en 'pseudo' BNF</h3>
	
	<p>Les messages du protocole doivent être extraits
	du flux continu d'octets. La solution actuelle consiste à
	désigner deux caractères donnés, CR et LF,
	comme séparateurs de messages. Les messages vides sont
	ignorés en silence, ce qui permet l'usage d'une suite de
	CR-LF entre les messages sans problèmes supplémentaires.
	<p>
	Le message extrait est décomposé en
	un &lt;préfixe&gt;, &lt;commande&gt; et liste de paramètres
	correspondant soit au composant &lt;milieu&gt; ou &lt;fin&gt;.
	<p>
	La représentation BNF de ceci est :<br>
	
	&lt;message&gt;  ::= [':' &lt;préfixe&gt;
	&lt;espace&gt; ] &lt;command&gt; &lt;params&gt; &lt;crlf&gt;
	<br>
	&lt;préfixe&gt;   ::= &lt;nom de serveur&gt;
	| &lt;pseudo&gt; [ '!' &lt;utilisateur&gt; ] [ '@' &lt;hôte&gt;
	]
	<br>
	&lt;command&gt;  ::= &lt;lettre&gt; { &lt;lettre&gt;
	} | &lt;nombre&gt; &lt;nombre&gt; &lt;nombre&gt;
	<br>
	&lt;espace&gt;    ::= ' ' { ' ' }
	<br>
	&lt;params&gt;   ::= &lt;espace&gt; [ ':' &lt;fin&gt;
	| &lt;milieu&gt; &lt;params&gt; ]<br>
	
	<br>
	&lt;milieu&gt;   ::= &lt;Toute séquence <b>non
	vide</b> d'octets à l'exclusion de ESPACE, NUL, CR, LF, le
	premier d'entre eux étant différent de ':'&gt;
	<br>
	&lt;fin&gt; ::= &lt;Toute suite, éventuellement
	vide, d'octets, à l'exception de NUL, CR et LF&gt;
	<br>
	
	&lt;crlf&gt;     ::= CR LF
	
	<p>
	NOTES:<br>
	
	1)  &lt;espace&gt; est constitué uniquement
	de caractère(s) ESPACE (0x20). Notez particulièrement
	que la TABULATION et tout autre caractère de contrôle
	sont considérés comme ESPACE-NON-BLANC.
	<p>
	2)  Après avoir extrait la liste de paramètres,
	tous les paramètres sont égaux, et correspondent
	soit à &lt;milieu&gt; soit à &lt;fin&gt;. &lt;Fin&gt;
	est une simple astuce syntaxique pour autoriser ESPACE dans le
	paramètre.
	<p>
	3)  Le fait que CR et LF ne puissent pas apparaître
	dans la chaîne paramètre est une simple assertion.
	Cela pourrait changer dans le futur.
	<p>
	4)  Le caractère NUL n'est pas spécial
	dans la construction du message, et pourrait a priori être
	à l'intérieur d'un message, mais cela complexifierait
	la gestion ordinaire des chaînes en C. C'est pourquoi NUL
	n'est pas autorisé dans les messages.
	<p>
	5)  Le dernier paramètre peut être une
	chaîne vide.
	<p>
	6)  L'utilisation d'un préfixe étendu
	([ '!' &lt;utilisateur&gt; ] [ '@' &lt;hôte&gt; ]) ne doit
	pas être utilisé dans la communication entre serveurs,
	et est destiné uniquement à la communication serveur
	vers client, dans le but de fournir au client des informations
	utiles à propos de l'origine du message sans nécessiter
	de requêtes supplémentaires.
	
	<p>
	La plupart des messages du protocole spécifient
	une sémantique additionnelle, et la syntaxe pour les chaînes
	de paramètres extraites est dictée par leur position
	dans la liste. Par exemple, de nombreuses commandes de serveurs
	vont considérer que le premier paramètre après
	la commande est la liste de destinataires, ce qui peut être
	décrit avec :<br>
	
	
	&lt;destinataire&gt;     ::= &lt;à&gt; [ ","
	&lt; destinataire &gt; ]
	<br>
	&lt;à&gt;         ::= &lt;canal&gt; | &lt;
	utilisateur &gt; '@' &lt;nom de serveur&gt; | &lt;pseudo&gt; |
	&lt;masque&gt;
	<br>
	&lt;canal&gt;    ::= ('#' | '&amp;') &lt;chaîne
	canal&gt;
	<br>
	&lt;nom de serveur&gt; ::= &lt;hôte&gt;
	<br>
	&lt;hôte&gt;       ::= voir RFC 952 [DNS:4]
	pour les détails sur les noms d'hôte autorisés
	<br>
	&lt;pseudo&gt;       ::= &lt;lettre&gt; { &lt;lettre&gt;
	| &lt;nombre&gt; | &lt;spécial&gt; }
	<br>
	&lt;masque&gt;       ::= ('#' | '$') &lt;chaîne
	canal&gt;
	<br>
	&lt;chaîne canal&gt;   ::= &lt;n'importe quel
	code 8bits excepté ESPACE, BELL, NUL, CR, LF et virgule
	(,)&gt;
	
	<p>
	Les autres paramètres sont :<br>
	
	&lt;utilisateur&gt;       ::= &lt;non blanc&gt; {
	&lt;non blanc&gt; }
	<br>
	&lt;lettre&gt;     ::= 'a' ... 'z' | 'A' ... 'Z'
	<br>
	&lt;nombre&gt;     ::= '0' ... '9'
	<br>
	&lt;spécial&gt;    ::= '-' | '[' | ']' | '\'
	| '`' | '^' | '{' | '}'
	
	<p>
	&lt;non blanc&gt;   ::= &lt;n'importe quel code
	8bits excepté ESPACE (0x20), NUL(0x0), CR(0xd), et LF(0xa)
	&gt;<br>
	
	<h2><a name="24">2.4</a>  Réponses numériques</h2>
	
	<p>La plupart des messages envoyés aux serveurs
	génèrent une réponse. Les réponses les
	plus courantes sont des réponses numériques, aussi
	bien pour les messages d'erreurs que pour les réponses
	normales. La réponse numérique est envoyée
	comme un message contenant le préfixe de l'expéditeur,
	le nombre de trois chiffres, et le destinataire de la réponse.
	Une réponse numérique ne peut pas émaner
	d'un client, et tout message de ce style reçu par un serveur
	doit être ignoré silencieusement. Hormis cela, une
	réponse numérique est un message comme un autre,
	si ce n'est que le mot-clé est composé de trois
	chiffres, plutôt que d'une suite de lettre. Une liste des
	réponses possibles est fournie à la section <a href="#6">6</a>.
	
	<h1><a name="3">3.</a>  Concepts IRC</h1>
	
	<p>Cette section décrit les concepts sous-jacents
	à l'organisation du protocole IRC et comment les implémentations
	actuelles délivrent les différentes classes de messages.
	<p>
	<pre>
	
							  1--\
								  A        D---4
							  2--/ \      /
									B----C
								   /      \
								  3        E
	   Serveurs: A, B, C, D, E         Clients: 1, 2,3, 4
	
						[ Fig. 2. Exemple d'un petit réseau IRC ]
	</pre>
	
	<h2><a name="31">3.1</a>  Communication un à un</h2>
	
	<p>La communication sur une base un à un n'est utilisée
	que par les clients, étant donné que la plupart
	du trafic serveur/serveur n'est pas dû aux serveurs
	qui se parlent entre eux. Afin de fournir un moyen sécurisé
	pour les clients de parler entre eux, il est nécessaire
	que tous les serveurs, pour atteindre un client, soient capables
	d'envoyer un message dans une seule direction sur l'arbre des
	connexions. Le chemin d'un message remis est le plus court entre
	deux points sur l'arbre.
	
	<p>
	Les exemples suivants se réfèrent tous
	à la figure 2 ci-dessus.
	
	<dl>
	<dt>
	Exemple 1 :
	<dd>
	Un message entre les clients 1et 2 n'est vu que par
	le serveur A, qui l'envoie directement au client 2.<br>
	
	<dt>
	Exemple 2 :
	<dd>
	Un message entre les clients 1 et 3 est vu par les
	serveurs A &amp; B, et par le client 3. Aucun autre client n'est
	autorisé à voir le message.<br>
	
	<dt>
	Exemple 3 :
	<dd>
	Un message entre les clients 2 et 4 n'est vu que
	par les serveurs A, B, C &amp; D et par le client 4.<br>
	</dl>
	
	<h2><a name="32">3.2</a>  Un à plusieurs</h2>
	
	<p>Le but principal d'IRC est de fournir un forum qui
	permette de réaliser des conférences de façon
	simple et efficace (conversation un à plusieurs). L'IRC
	offre plusieurs moyens de le réaliser, chacun avec des buts
	différents.
	
	<h3><a name="321">3.2.1</a>  À une liste</h3>
	
	<p>Le moyen le moins efficace d'avoir une conversation
	un à plusieurs consiste, pour chaque client, à parler
	à une 'liste' d'utilisateurs. La façon dont cela
	se fait est triviale : chaque client donne une liste de
	destinataires auxquels le message doit être délivré,
	et le serveur disperse le message et en distribue une copie
	à chacun des destinataires. Ce n'est pas aussi efficace
	que l'utilisation d'un groupe puisque la liste de destinataires
	est décomposée et la distribution a lieu sans vérifier
	si le message est envoyé en double sur un même
	chemin.
	
	<h3><a name="322">3.2.2</a>  À un groupe (canal)</h3>
	
	<p>Sur IRC, un canal a un rôle équivalent
	à celui d'un groupe de multi-diffusion ; son existence
	est dynamique (il va et vient au fur et à mesure
	que les gens accèdent et quittent le canal) et la conversation
	qui a lieu sur un canal n'est envoyée qu'aux serveurs qui
	ont des utilisateurs sur ce canal. Cette action est alors répétée
	par chaque combinaison client/serveur jusqu'à ce que le
	message original ait atteint tous les membres d'un canal.
	
	<p>
	Les exemples suivants se réfèrent tous
	à la figure 2.
	
	<dl>
	<dt>
	Exemple 4 :
	<dd>
	Pour tout canal qui contient un seul client, les
	messages du canal vont au serveur et nulle part ailleurs.<br>
	
	<dt>
	Exemple 5 :
	<dd>
	Il y a deux clients dans un canal. Tous les messages
	traversent le chemin comme s'ils étaient des messages privés
	entre les deux clients en dehors du canal.<br>
	
	<dt>
	Exemple 6 :
	<dd>
	Les clients 1, 2 et 3 sont dans un canal. Tous les
	messages adressés à un canal sont envoyés
	à tous les clients, et à ceux des serveurs qui seraient
	traversés par le message s'il était un message privé
	entre deux clients. Si le client 1 envoie un message, il est envoyé
	au client 2, et par le serveur B, au client 3.
	</dl>
	
	<h3><a name="323">3.2.3</a> À un masque d'hôte/de serveur</h3>
	
	<p>Afin de fournir aux opérateurs IRC un mécanisme
	pour envoyer des messages à un grand nombre d'utilisateurs
	apparentés, on fournit des masques de serveurs et d'hôtes.
	Ces messages sont envoyés aux serveurs et
	aux hôtes dont l'adresse correspond au masque. Ces messages
	ne sont envoyés qu'aux endroits où il y a des utilisateurs,
	de la même façon que pour les canaux.
	
	<h2><a name="33">3.3</a>  Un à tous</h2>
	
	<p>Les messages un à tous peuvent être
	décrits comme des messages de diffusion, envoyés
	à tous les clients, tous les serveurs, ou les deux. Sur un grand
	réseau d'utilisateurs et de serveurs, un simple message
	peut générer beaucoup de trafic, puisqu'il est envoyé
	à travers le réseau pour atteindre toutes les destinations.
	
	<p>
	Pour certains messages, il est nécessaire
	de les diffuser à tous les serveurs, afin
	que les informations de statut de chaque serveur soient raisonnablement
	identiques entre tous les serveurs.
	
	<h3><a name="331">3.3.1</a>  Client à client</h3>
	
	<p>Il n'y a pas de classe de message qui, à partir
	d'un simple message, résulte en un message envoyé
	à tous les autres clients.
	
	<h3><a name="332">3.3.2</a>  Client à serveur</h3>
	
	<p>La plupart des commandes qui résultent en
	un changement d'état (tels que l'appartenance à
	un canal, le mode d'un canal, le statut d'un utilisateur, etc.)
	doivent être, par défaut, envoyés à tous les serveurs, et le
	client ne peut pas changer cette distribution.
	
	<h3><a name="333">3.3.3</a>  Serveur à serveur</h3>
	
	<p>Bien que la plupart des messages entre les serveurs
	soient distribués à 'tous' les autres serveurs,
	cela n'est nécessaire que pour les messages qui affectent
	soit un utilisateur, soit un canal, soit un serveur. Etant donné
	que cela constitue l'essentiel des éléments de l'IRC,
	la quasi-totalité des messages issus d'un serveur est diffusée
	à tous les autres serveurs connectés.
	
	<h2><a name="4">4.</a>  Détails des messages</h2>
	
	<p>Les pages suivantes décrivent les messages
	reconnus par les serveurs IRC et les clients. Toutes les commandes
	décrites dans cette section doivent être implémentées
	par tous les serveurs utilisant ce protocole.
	
	<p>
	Si la réponse ERR_NOSUCHSERVER est reçue,
	cela signifie que le paramètre &lt;serveur&gt; n'a pas
	été trouvé. Le serveur ne doit alors plus
	envoyer d'autres réponses pour cette commande.
	<p>
	Le serveur auquel un client est connecté doit
	traiter le message complet, et retourner les messages d'erreur
	appropriés. Si le serveur rencontre une erreur fatale en
	décomposant un message, une erreur doit être envoyée
	au client et la décomposition interrompue. Peuvent être
	considérés comme une erreur fatale une commande incorrecte,
	une destination inconnue du serveur (noms de serveur, pseudo,
	et noms de canaux entrent dans cette catégorie), un nombre
	de paramètres insuffisant, ou un niveau de privilège
	insuffisant.
	<p>
	Si un jeu de paramètres complet est présent,
	la validité de chacun d'entre eux doit être vérifiée,
	et les réponses appropriées envoyées au client.
	Dans le cas de messages dont la liste de paramètres utilise
	une virgule comme séparateur, une réponse doit être
	envoyée à chaque élément.
	<p>
	Dans les exemples suivants, certains messages apparaissent
	au format complet :<br>
	
	:Nom COMMANDE paramètre liste
	<p>
	Ces exemples représentent un message de "Nom"
	dans le transfert entre serveurs, où il est essentiel d'inclure
	le nom de l'expéditeur originel du message, de façon
	à ce que les serveurs distants puissent renvoyer un message
	le long d'un chemin valide.
	
	<h2><a name="41">4.1</a>  Établissement de connexion</h2>
	
	<p>Les commandes décrites dans cette section
	sont utilisées pour établir une connexion avec
	un serveur IRC, aussi bien par un client que par un serveur, ainsi
	qu'une déconnexion correcte.
	<p>
	Une commande "PASS" n'est pas nécessaire
	pour établir une connexion, mais elle doit précéder
	la combinaison suivante des messages NICK/USER. Il est fortement
	recommandé que toutes les connexions de serveurs utilisent
	un mot de passe afin de donner un niveau de sécurité
	satisfaisant aux connexions. L'ordre des commandes recommandé
	pour l'enregistrement d'un client est le suivant :<br>
	
	1.  Message PASS<br>
	2.  Message NICK<br>
	3.  Message USER<br>
	
	<h3><a name="411">4.1.1</a>  Message PASS</h3>
	
	<p>Commande : PASS<br>
	Paramètres : &lt;mot de passe&gt;
	
	<p>
	La commande PASS est utilisée pour définir
	le 'mot de passe de connexion'. Le mot de passe peut et doit
	être défini avant toute tentative de connexion.
	A l'heure actuelle, cela signifie que les clients doivent  envoyer
	une commande PASS avant d'envoyer la combinaison NICK/USER, et
	que les serveurs <b>doivent</b> envoyer une commande PASS avant toute
	commande SERVER. Le mot de passe fourni doit correspondre à
	celui contenu dans les lignes C/N (pour les serveurs) ou dans
	les lignes I (pour les clients). Il est possible d'envoyer plusieurs
	commandes PASS avant de s'enregistrer, mais seule
	la dernière est utilisée pour la vérification,
	et elle ne peut plus changer une fois la connexion établie.
	
	<p>
	Réponses numériques :<br>
	
	<pre>
	ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED
	</pre>
	
	<p>Exemple:<br>
	
			   PASS motdepasssecretici
	
	<h3><a name="412">4.1.2</a> Message NICK</h3>
	
	<p>Commande : NICK<br>
	Paramètres : &lt;pseudonyme&gt; [ &lt;compteur
	de distance&gt; ]
	<p>
	Le message NICK est utilisé pour donner un
	pseudonyme à un utilisateur, ou pour changer le pseudonyme
	précédent. Le paramètre &lt;compteur de distance&gt;
	n'est utilisé que par les serveurs, et sert à indiquer
	quelle est la distance entre un utilisateur et son serveur local.
	Une connexion locale a un compteur de distance de zéro.
	Si un client fournit un compteur de distance, il doit être
	ignoré.
	<p>
	Si un message NICK arrive à un serveur qui
	connaît déjà un autre client de pseudo identique,
	une collision de pseudonymes a lieu. Le résultat d'une
	collision de pseudonymes est la suppression de toutes les instances
	du pseudonyme de la base du serveur, et l'envoi d'un message KILL
	afin de retirer le pseudonyme des bases de données de tous
	les autres serveurs. Si le message NICK à l'origine de
	la collision de pseudonymes est un changement de pseudonyme, alors
	le pseudo originel (l'ancien) doit aussi être retiré.
	
	<p>
	Si le serveur reçoit un NICK identique d'un
	client auquel il est connecté directement, il peut envoyer
	un ERR_NICKCOLLISION au client local, ignorer la commande NICK,
	et ne pas générer de KILLs.
	<p>
	Réponses numériques :<br>
	<pre>
			   ERR_NONICKNAMEGIVEN             ERR_ERRONEUSNICKNAME
			   ERR_NICKNAMEINUSE               ERR_NICKCOLLISION
	</pre>
	
	<p>Exemples:
	<ul>
	   <tt>NICK Wiz</tt>                        ; Ajout d'un nouveau
	pseudo "Wiz".<br>
	
	   <tt>:WiZ NICK Kilroy</tt>                ; WiZ change son
	pseudo en Kilroy.
	</ul>
	
	<h3><a name="413">4.1.3</a> Message USER</h3>
	
	<p>Commande: USER<br>
	Paramètres: &lt;nom d'utilisateur&gt; &lt;hôte&gt;
	&lt;nom de serveur&gt; &lt;nom réel&gt;
	
	<p>
	Le message USER est utilisé au début
	d'une connexion pour spécifier le nom d'utilisateur, le
	nom d'hôte, le nom de serveur, et le véritable nom
	d'un nouvel utilisateur. Il est aussi utilisé lors de la
	communication entre les serveurs pour indiquer l'arrivée
	d'un nouvel utilisateur sur IRC, puisque c'est seulement après
	avoir envoyé et le USER et le NICK qu'un utilisateur devient
	enregistré.
	<p>
	Entre serveurs, USER doit être préfixé
	du pseudonyme du client. Notez que le nom d'hôte et le nom
	de serveur sont généralement ignorés par
	le serveur IRC quand la commande USER vient directement d'un client
	(pour des raisons de sécurité), mais sont utilisés
	dans la communication de serveur à serveur. Cela signifie
	que NICK doit toujours être envoyé à un serveur
	distant quand un nouvel utilisateur est ajouté au reste
	du réseau, avant que le USER correspondant soit envoyé.
	<p>
	Notez aussi que le paramètre 'vrai nom' doit
	être le dernier paramètre, car il peut contenir des
	espaces, et il doit être préfixé par deux
	points (':') de façon à être reconnu comme
	tel.
	<p>
	Puisqu'il est facile pour un client de mentir sur
	son nom si on se base uniquement sur le message USER, il est recommandé
	d'utiliser un "serveur d'identité". Si l'hôte
	dont l'utilisateur se connecte a un serveur de ce type activé,
	le nom d'utilisateur est défini par la réponse de
	ce "serveur d'identité".
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED
	</pre>
	
	<p>Exemples:
	<ul>
	<tt>USER guest tolmoon tolsun :Ronnie Reagan</tt>
	; Utilisateur s'enregistrant avec un nom d'utilisateur
	de "guest" et un vrai nom de "Ronnie Reagan".
	
	<tt>:testnick USER guest tolmoon tolsun :Ronnie Reagan</tt>
	; message entre les serveurs contenant le pseudonyme
	à qui appartient la commande USER.
	</ul>
	
	<h3><a name="414">4.1.4</a>  Message SERVER</h3>
	
	<p>Commande: SERVER<br>
	Paramètres: &lt;nom de serveur&gt; &lt;compteur
	de distance&gt; &lt;info&gt;<p>
	
	Le message SERVER est utilisé pour dire à
	un serveur que l'autre bout de la connexion est un autre serveur.
	Ce message est aussi utilisé pour transmettre les données
	du serveur à tout le réseau. Quand un nouveau serveur
	se connecte au réseau, les informations le concernant sont
	diffusées à tout le réseau. &lt;Compteur
	de distance&gt; est utilisé pour donner à chaque
	serveur des informations sur leurs distances aux différents
	serveurs. Avec la liste complète des serveurs, il serait
	possible de construire une carte complète de l'arbre des
	serveurs, mais les masques d'hôtes l'en empêchent.
	<p>
	Le message SERVER doit être accepté
	uniquement (a) soit d'une connexion qui n'est pas encore enregistrée
	et qui essaie de s'enregistrer en tant que serveur, ou (b) d'une
	connexion existante d'un autre serveur, pour introduire un nouveau
	serveur au delà de ce serveur.
	<p>
	La plupart des erreurs qui ont lieu à la réception
	d'une commande SERVER résulte en la coupure de la connexion
	avec l'hôte destinataire (serveur destinataire). Les réponses
	d'erreur sont généralement envoyées en utilisant
	la commande "ERROR" plutôt qu'une réponse
	numérique, car la commande ERROR a plusieurs propriétés
	qui la rendent utile dans ce cas.
	<p>
	Si un message SERVER est traité et tente d'introduire
	un serveur déjà connu du serveur receveur, la connexion
	avec ce serveur doit être coupée (en suivant les procédures
	correctes), car une route dupliquée s'est formée
	avec un serveur, et la nature acyclique de l'arbre IRC est rompue.
	
	<p>
	Réponses numériques :
	<Pre>
			   ERR_ALREADYREGISTRED<br>
	
	</pre>
	<p>Exemples :
	
	<ul>
	<tt>SERVER test.oulu.fi 1 :[tolsun.oulu.fi] Experimental
	server</tt><br>
	; Le nouveau serveur test.oulu.fi se présente
	et tente de s'enregistrer. Le nom d'hôte est test.oulu.fi.
	<p>
	
	<tt>:tolsun.oulu.fi SERVER csd.bu.edu 5 :BU Central Server</tt><br>
	; Le serveur tolsun.oulu.fi est notre lien vers csd.bu.edu
	qui est à 5 nœuds de nous.
	</ul>
	
	<h3><a name="415">4.1.5</a> Message OPER</h3>
	
	<p>Commande: OPER<br>
	Paramètres: &lt;utilisateur&gt; &lt;mot de
	passe&gt;
	<p>
	Le message OPER est utilisé par un utilisateur
	normal pour obtenir le privilège d'opérateur. La
	combinaison de &lt;utilisateur&gt; et &lt;mot de passe&gt; est
	nécessaire pour obtenir le privilège Opérateur.
	
	<p>
	Si le client envoyant la commande OPER fournit un
	mot de passe correct pour l'utilisateur donné, le serveur
	informe le reste du réseau du nouvel opérateur en
	envoyant un "MODE +o" pour le pseudonyme.
	<p>
	Le message OPER n'a lieu qu'entre un client et un
	serveur.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NEEDMOREPARAMS              RPL_YOUREOPER
			   ERR_NOOPERHOST                  ERR_PASSWDMISMATCH
	</pre>
	<p>Exemple:
	<ul>
	<tt>OPER foo bar</tt><br>
	; Tentative d'enregistrement en tant qu'opérateur,
	de l'utilisateur "foo" utilisant "bar" comme
	mot de passe.
	</ul>
	
	<h3><a name="416">4.1.6</a> Message QUIT</h3>
	
	<p>Commande: QUIT<br>
	Paramètres: [&lt;Message de départ
	&gt;]
	<p>
	Une session de client se termine par un message QUIT.
	Le serveur doit rompre la connexion avec le client qui envoie
	un message QUIT. Si un &lt;Message de départ&gt; est fourni,
	il sera transmis au lieu du message par défaut, le pseudonyme.
	
	<p>
	Lorsqu'une division réseau a lieu (déconnexion
	de deux serveurs), le message de départ est composé
	du nom des deux serveurs en cause, séparés par un
	espace. Le premier nom est celui du serveur toujours connecté,
	et le second, celui qui est désormais inaccessible.
	<p>
	Si pour une autre raison, une connexion d'un client
	est fermée sans que le client ait envoyé de message
	QUIT (par exemple, le programme client se termine, et une fin
	de fichier est envoyée sur la socket), le serveur doit
	remplir le message QUIT avec un message reflétant la nature
	de l'événement à l'origine de cette déconnexion.
	
	<p>
	Réponses numériques:<br>
	
	<Pre>
			   Aucune.
	</pre>
	<p>Exemples:
	<ul>
	   <tt>QUIT :Parti déjeuner</tt> ; Format de message
	préféré.
	</ul>
	
	<h3><a name="417">4.1.7</a> Message SQUIT</h3>
	
	<p>Commande: SQUIT<br>
	Paramètres: &lt;serveur&gt; &lt;commentaire&gt;
	
	<p>
	Le message SQUIT est nécessaire pour signaler
	le départ ou la mort de serveurs. Si un serveur souhaite
	rompre une connexion à un autre serveur, il doit envoyer
	un message SQUIT à ce serveur, en utilisant le nom de ce
	serveur comme paramètre &lt;serveur&gt;, ce qui clôt la
	connexion avec le serveur quittant le réseau.
	<p>
	Cette commande est aussi accessible aux opérateurs
	pour garder un réseau de serveurs IRC connectés
	proprement. Les opérateurs peuvent également émettre
	un message SQUIT pour une connexion distante d'un serveur. Dans
	ce cas, le message SQUIT doit être traité par tous
	les serveurs entre l'opérateur et le serveur distant, tout
	en mettant à jour la vue du réseau de chaque serveur
	comme décrit plus loin.
	<p>
	Le &lt;commentaire&gt; doit être fourni
	par tous les opérateurs qui exécutent un SQUIT sur un
	serveur distant (qui n'est pas connecté au serveur sur
	lequel ils sont actuellement). Le &lt;commentaire&gt; est également
	rempli par les serveurs qui peuvent y placer un message d'erreur
	ou autre.
	<p>
	Les deux serveurs, de chaque côté de la connexion
	qui va être coupée, doivent envoyer un message SQUIT
	(à tous les serveurs auxquels ils sont connectés)
	vers tous les serveurs qui sont situés au-delà de
	ce lien.
	<p>
	De même, un message QUIT doit être envoyé
	aux autres serveurs du reste du réseau de la part de tous
	les clients au-delà de ce lien. De plus, tous les membres
	d'un canal qui perd un membre à cause d'une division
	réseau doivent recevoir un message QUIT.
	<p>
	Si une connexion à un serveur est terminée
	prématurément, (par exemple si le serveur à
	l'extrémité de la liaison meurt), le serveur qui
	détecte cette déconnexion doit informer le reste
	du réseau que cette connexion est fermée, et remplir
	le champ &lt;commentaire&gt; de façon appropriée.
	
	<p>
	Réponses numériques :
	<pre>
			   ERR_NOPRIVILEGES                ERR_NOSUCHSERVER
	</pre>
	<p>Exemples:
	<UL>
	<tt>SQUIT tolsun.oulu.fi :Bad Link ? </tt><br>
	; la liaison au serveur tolson.oulu.fi s'est terminée
	en raison d'un mauvais lien.
	<p>
	<tt>:Trillian SQUIT cm22.eng.umd.edu :Server out of control</tt><br>
	; message de Trillian pour déconnecter "cm22.eng.umd.edu"
	du réseau en raison d'un "serveur incontrôlable".
	</ul>
	
	<h2><a name="42">4.2</a> Opérations sur les canaux</h2>
	
	<p>Ce groupe de messages s'intéresse à
	la manipulation de canaux, à leurs propriétés
	(mode des canaux), et à leur contenu (typiquement des clients).
	En implémentant ces commandes, la résolution de
	conflits entre les clients est inévitable, par exemple
	lorsque deux clients à deux extrémités du
	réseau envoient des commandes incompatibles. Il est aussi
	nécessaire aux serveurs de garder l'historique d'un pseudonyme
	afin que, quand un paramètre &lt;pseudo&gt;
	est donné, le serveur puisse vérifier dans l'historique
	si le pseudo n'a pas changé récemment.
	
	<h3><a name="421">4.2.1</a>  Message JOIN</h3>
	
	<p>Commande: JOIN<br>
	Paramètres: &lt;canal&gt;{,&lt;canal&gt;}
	[&lt;clé&gt;{,&lt;clé&gt;}]
	<p>
	La commande JOIN est utilisée par un client
	pour commencer à écouter un canal spécifique.
	L'accès à un canal est autorisé ou non uniquement
	par le serveur auquel le client est connecté ; tous les
	autres serveurs ajoutent automatiquement l'utilisateur au canal
	quand la demande vient d'un autre serveur. Les conditions qui
	affectent ceci sont les suivantes :<br>
	1.  L'utilisateur doit être invité si
	le canal est en mode "sur invitation seulement"<br>
	2.  Le pseudo/nom d'utilisateur/nom d'hôte
	ne doit pas correspondre à un bannissement actif.<br>
	3.  La bonne clé (mot de passe) doit être
	fournie si elle est définie.
	<p>
	Ceci est discuté plus en détails dans
	la description de la commande MODE (voir la section <a href="#423">4.2.3</a> pour
	plus de détails).
	<p>
	Une fois qu'un utilisateur a accès à
	un canal, il reçoit des notifications de toutes les
	commandes que son serveur reçoit et qui affectent le canal.
	Cela inclut MODE, KICK, PART, QUIT, et bien sûr PRIVMSG/NOTICE.
	La commande JOIN doit être diffusée à tous
	les serveurs du réseau pour qu'ils sachent où trouver
	qui est dans chaque canal. Cela permet une distribution optimale
	des messages PRIVMSG/NOTICE du canal.
	<p>
	Si un JOIN a lieu avec succès, on envoie à
	l'utilisateur le sujet du canal (en utilisant RPL_TOPIC) et la
	liste des utilisateurs du canal (en utilisant RPL_NAMREPLY), y
	compris lui-même.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NEEDMOREPARAMS              ERR_BANNEDFROMCHAN
			   ERR_INVITEONLYCHAN              ERR_BADCHANNELKEY
			   ERR_CHANNELISFULL               ERR_BADCHANMASK
			   ERR_NOSUCHCHANNEL               ERR_TOOMANYCHANNELS
			   RPL_TOPIC
	</pre>
	<p>Exemples:
	<ul>
	   <tt>JOIN #foobar</tt>                    ; accède
	au canal #foobar.
	<p>
	   <tt>JOIN &amp;foo fubar</tt>                 ; accède
	au canal &amp;foo en utilisant la clé "fubar".
	<p>
	   <tt>JOIN #foo,&amp;bar fubar</tt>            ; accède
	au canal #foo en utilisant la clé "fubar", et
	&amp;bar en n'utilisant pas de clé.
	<p>
	   <tt>JOIN #foo,#bar fubar,foobar</tt>     ; accède
	au canal #foo en utilisant la clé "fubar", et
	au canal #bar en utilisant la clé "foobar".
	<p>
	   <tt>JOIN #foo,#bar</tt>                  ; accède
	au canaux #foo and #bar.
	<p>
	   <tt>:WiZ JOIN #Twilight_zone</tt>        ; message JOIN
	de WiZ
	</ul>
	
	<h3><a name="422">4.2.2</a> Message PART</h3>
	
	<p>Commande: PART<br>
	Paramètres: &lt;canal&gt;{,&lt; canal &gt;}
	
	<p>
	Le message PART provoque le retrait du client expéditeur
	de la liste des utilisateurs actifs pour tous les canaux listés
	dans la chaîne de paramètres.
	<p>
	Réponses numériques:
	<Pre>
			   ERR_NEEDMOREPARAMS              ERR_NOSUCHCHANNEL
			   ERR_NOTONCHANNEL<br>
	</Pre>
	<p>Exemples:
	<ul>
	   <tt>PART #twilight_zone</tt>             ; quitte le canal
	"#twilight_zone"
	<p>
	   <tt>PART #oz-ops,&amp;group5</tt>            ; quitte les
	canaux "&amp;group5" et "#oz-ops".
	</ul>
	
	<h3><a name="423">4.2.3</a> Message MODE</h3>
	
	<p>Commande: MODE
	<p>
	La commande MODE est une commande à utilisation
	duale sur IRC. Elle permet aussi bien de changer les modes des
	utilisateurs que ceux des canaux. La raison à ce choix
	est qu'un jour les pseudonymes deviendront obsolètes et
	la propriété équivalente sera le canal.
	<p>
	Lors du traitement des messages MODE, il est recommandé
	de commencer par décomposer le message en entier, puis
	de réaliser les modifications résultantes.<br>
	
	<h4><a name="4231">4.2.3.1</a>  Les modes des canaux </h4>
	
	<p>Paramètres: &lt;canal&gt; {[+|-]|o|p|s|i|t|n|b|v}
	[&lt;limite&gt;] [&lt;utilisateur&gt;]  [&lt;masque de bannissement
	&gt;]
	<p>
	La commande MODE permet aux opérateurs de
	canal de changer les caractéristiques de 'leur' canal.
	Les serveurs doivent aussi pouvoir changer les modes du canal,
	de façon à pouvoir créer des opérateurs.
	
	<p>
	Les modes disponibles pour les canaux sont les suivants
	:<br>
	
	o -  donne/retire les privilèges d'opérateur
	de canal<br>
	p - drapeau de canal privé<br>
	s - drapeau de canal secret<br>
	i - drapeau de canal accessible uniquement sur invitation<br>
	t - drapeau de sujet de canal modifiable uniquement
	par les opérateurs<br>
	n - pas de messages dans un canal provenant de clients
	à l'extérieur du canal<br>
	m - canal modéré<br>
	l - définit le nombre maximal de personnes
	dans un canal<br>
	b - définit un masque de bannissement pour
	interdire l'accès à des utilisateurs<br>
	v - donne/retire la possibilité de parler
	dans un canal modéré<br>
	k -  définit la clé du canal (mot de
	passe)
	<p>
	Lors de l'utilisation des options 'o' et 'b', le
	nombre de paramètres est restreint à trois par commande,
	et ce pour n'importe quelle combinaison de 'o' et de 'b'.
	
	<h4><a name="4232">4.2.3.2</a>  Modes des utilisateurs</h4>
	
	<p>Paramètres: &lt;pseudonyme&gt; {[+|-]|i|w|s|o}
	
	<p>
	Les modes utilisateurs sont typiquement des modifications
	qui affectent la façon dont le client est vu par les autres,
	ou quels types de messages sont reçus. Une commande MODE
	n'est acceptée que si l'expéditeur du message et
	le pseudonyme donné en paramètre sont les mêmes.
	
	<p>
	Les modes disponibles sont :<br>
	i - marque un utilisateur comme invisible ;<br>
	s - marque un utilisateur comme recevant les notifications
	du serveur ;<br>
	w - l'utilisateur reçoit les WALLOPs ;<br>
	o - drapeau d'opérateur.
	
	<p>
	D'autres modes seront disponibles plus tard.
	<p>
	Si un utilisateur tente de devenir opérateur
	en utilisant le drapeau "+o", la tentative doit être
	ignorée. Par contre, il n'y a pas de restriction à
	ce que quelqu'un se 'deoppe' (en utilisant "-o").
	<p>
	Réponses numériques :
	<pre>
			   ERR_NEEDMOREPARAMS              RPL_CHANNELMODEIS
			   ERR_CHANOPRIVSNEEDED            ERR_NOSUCHNICK
			   ERR_NOTONCHANNEL                ERR_KEYSET
			   RPL_BANLIST                     RPL_ENDOFBANLIST
			   ERR_UNKNOWNMODE                 ERR_NOSUCHCHANNEL
	
			   ERR_USERSDONTMATCH              RPL_UMODEIS
			   ERR_UMODEUNKNOWNFLAG<br>
	</pre>
	<p>Exemples:
	<ul>
	Utilisation des modes de canal:<br>
	
	<tt>MODE #Finnish +im</tt>               ; Rend le canal #Finnish
	modéré et 'uniquement sur invitation'.<br>
	
	<tt>MODE #Finnish +o Kilroy</tt>         ; Donne le privilège
	de 'chanop' à Kilroy sur le canal #Finnish.<br>
	
	<tt>MODE #Finnish +v Wiz</tt>            ; Autorise WiZ à
	parler sur #Finnish.<br>
	
	<tt>MODE #Fins -s</tt>                   ; Annule le drapeau
	'secret' du canal #Fins.<br>
	
	<tt>MODE #42 +k oulu</tt>                ; Définit la
	clé comme "oulu".<br>
	
	<tt>MODE #eu-opers +l 10</tt>            ; Définit le
	nombre maximal d'utilisateurs dans le canal à 10.<br>
	
	<tt>MODE &amp;oulu +b</tt>                   ; Liste les masques
	de bannissement du canal.<br>
	
	<tt>MODE &amp;oulu +b *!*@*</tt>             ; Interdit à
	quiconque de venir sur le canal.<br>
	
	<tt>MODE &amp;oulu +b *!*@*.edu</tt>         ; Interdit à
	tout utilisateur dont le nom d'hôte correspond à
	*.edu d'accéder au canal.
	<p>
	Utilisation des modes d'utilisateur :<br>
	
	<tt>:MODE WiZ -w</tt>                    ; supprime la réception
	des messages WALLOPS pour WiZ.<br>
	
	<tt>:Angel MODE Angel +i</tt>            ; Message d'Angel
	pour se rendre invisible.<br>
	
	<tt>MODE WiZ -o</tt>                     ; WiZ se 'deoppe'
	(retire son statut d'opérateur). Le contraire ("MODE
	WiZ +o") ne doit pas être autorisé car cela
	court-circuiterait la commande OPER.
	
	</ul>
	
	<h3><a name="424">4.2.4</a> Message TOPIC</h3>
	
	<p>Commande: TOPIC<br>
	Paramètres: &lt;canal&gt; [&lt;sujet&gt;]
	
	<p>
	Le message TOPIC est utilisé pour modifier
	ou voir le sujet d'un canal. Le sujet du canal &lt;canal&gt; est
	renvoyé s'il n'y a pas de &lt;sujet&gt; fourni en paramètre.
	Si le paramètre &lt;sujet&gt; est présent, le sujet
	du canal changera si le mode du canal le permet.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NEEDMOREPARAMS              ERR_NOTONCHANNEL
			   RPL_NOTOPIC                     RPL_TOPIC
			   ERR_CHANOPRIVSNEEDED<br>
	</Pre>
	<p>Exemples:
	<ul>
	   <tt>:Wiz TOPIC #test :New topic</tt>     ; L'utilisateur
	Wiz définit le sujet.<br>
	
	   <tt>TOPIC #test :another topic</tt>      ; Change le sujet
	du canal #test en "another topic".<br>
	
	   <tt>TOPIC #test</tt>                     ; Vérifie
	le sujet de #test.
	</ul>
	
	<h3><a name="425">4.2.5</a> Message NAMES</h3>
	
	<p>Commande: NAMES<br>
	Paramètres: [&lt;canal&gt;{,&lt;canal&gt;}]
	
	<p>
	En utilisant la commande NAMES, un utilisateur peut
	obtenir la liste des pseudonymes visibles sur n'importe quel canal
	qu'il peut voir. Les noms de canaux qu'il peut voir sont ceux
	qui ne sont ni privés (+p), ni secrets (+s), ou ceux sur
	lesquels il est actuellement. Le paramètre &lt;canal&gt;
	spécifie quels sont les canaux dont l'information est voulue,
	s'ils sont valides. Il n'y a pas de message d'erreur pour les
	noms de canaux invalides.
	<p>
	Si le paramètre &lt;canal&gt; n'est pas donné,
	la liste de tous les canaux et de leurs occupants est renvoyée.
	A la fin de cette liste, sont listés les utilisateurs visibles,
	mais qui n'appartiennent à aucun canal visible.
	Ils sont listés comme appartenant au 'canal' "*".
	
	<p>
	Réponses numériques:
	<Pre>
			   RPL_NAMREPLY                    RPL_ENDOFNAMES
	</pre>
	<p>Exemples:
	<ul>
	<tt>NAMES #twilight_zone,#42</tt>        ; liste les utilisateurs
	visibles sur #twilight_zone et #42, si ces canaux vous sont visibles.<br>
	
	<tt>NAMES</tt>                           ; liste tous les
	canaux, et tous les utilisateurs visibles.
	</ul>
	
	<h3><a name="426">4.2.6</a> Message LIST</h3>
	
	<p>Commande: LIST<br>
	Paramètres: [&lt;canal&gt;{,&lt;canal&gt;}
	[&lt;serveur&gt;]]
	<p>
	Le message LIST est utilisé pour lister les
	canaux et leur sujet. Si le paramètre &lt;canal&gt; est
	utilisé, seul le statut de ces canaux est affiché.
	Les canaux privés sont listés (sans leur sujet)
	comme canal "Prv" à moins que le client qui génère
	la requête soit effectivement sur le canal. De même,
	les canaux secrets ne sont pas listés du tout, à
	moins que le client soit un membre du canal en question.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER                RPL_LISTSTART
			   RPL_LIST                        RPL_LISTEND
	</pre>
	<p>Exemples:
	<ul>
	   <tt>LIST</tt>                            ; Liste tous les
	canaux.<br>
	
	   <tt>LIST #twilight_zone,#42</tt>         ; Liste les canaux
	#twilight_zone et #42
	</ul>
	
	<h3><a name="427">4.2.7</a> Message INVITE</h3>
	
	<p>Commande: INVITE<br>
	Paramètres: &lt;pseudonyme&gt; &lt;canal&gt;
	
	<p>
	Le message INVITE est utilisé pour inviter
	des utilisateurs dans un canal. Le paramètre &lt;pseudonyme&gt;
	est le pseudonyme de la personne à inviter dans le canal
	destination &lt;canal&gt;. Il n'est pas nécessaire que
	le canal dans lequel la personne est invitée existe, ni
	même soit valide. Pour inviter une personne dans un canal
	en mode sur invitation (MODE +i), le client envoyant l'invitation
	doit être opérateur sur le canal désigné.
	
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NEEDMOREPARAMS              ERR_NOSUCHNICK
			   ERR_NOTONCHANNEL                ERR_USERONCHANNEL
			   ERR_CHANOPRIVSNEEDED
			   RPL_INVITING                    RPL_AWAY
	</pre>
	<p>Exemples:
	<ul>
	<tt>:Angel INVITE Wiz #Dust</tt>         ; L'utilisateur Angel
	invite WiZ sur le canal #Dust<br>
	
	<tt>INVITE Wiz #Twilight_Zone</tt>       ; Commande pour
	inviter WiZ sur #Twilight_zone
	</ul>
	
	<h3><a name="428">4.2.8</a> Commande KICK</h3>
	
	<p>Commande: KICK<br>
	Paramètres: &lt;canal&gt; &lt;utilisateur&gt;
	[&lt;commentaire&gt;]
	<p>
	La commande KICK est utilisée pour retirer
	par la force un utilisateur d'un canal (PART forcé).
	<p>
	Seul un opérateur de canal peut kicker un
	autre utilisateur hors d'un canal. Tout serveur qui reçoit
	un message KICK vérifie si le message est valide (c'est-à-dire
	si l'expéditeur est bien un opérateur du canal)
	avant d'ôter la victime du canal.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NEEDMOREPARAMS              ERR_NOSUCHCHANNEL
			   ERR_BADCHANMASK                 ERR_CHANOPRIVSNEEDED
			   ERR_NOTONCHANNEL
	</Pre>
	<p>Exemples:
	<ul>
	<tt>KICK &amp;Melbourne Matthew</tt>         ; Kick Matthew
	de &amp;Melbourne<br>
	
	<tt>KICK #Finnish John :Speaking English</tt>
	; Kick John de #Finnish en spécifiant "Speaking
	English" comme raison (commentaire).<br>
	
	<tt>:WiZ KICK #Finnish John</tt>         ; Message KICK de
	WiZ pour retirer John du canal #Finnish<br>
	</ul>
	
	<p>
	NOTE:
	<p>
		 Il est possible d'étendre les paramètres
	de la commande KICK ainsi :<br>
	
	&lt;canal&gt;{,&lt;canal&gt;} &lt;utilisateur&gt;{,&lt;utilisateur&gt;}
	[&lt;commentaire&gt;]
	
	<h2><a name="43">4.3</a>  Requêtes et commandes des serveurs</h2>
	
	<p>Le groupe de requêtes de commande des serveurs
	sert à obtenir des informations au sujet de tout serveur
	connecté au réseau. Tous les serveurs connectés
	doivent répondre à ces requêtes et répondre
	correctement. Toute réponse invalide (ou l'absence de réponse)
	doit être considéré comme un signe de serveur
	cassé, et il doit se déconnecter / se désactiver
	au plus tôt, jusqu'à ce que le problème soit
	résolu.
	<p>
	Dans ces requêtes, lorsqu'il y a un paramètre
	"&lt;serveur&gt;", cela désigne généralement
	un pseudonyme, un serveur, ou un joker quelconque. Par contre,
	chaque paramètre ne doit générer qu'une seule
	requête et un jeu de réponses.
	
	<h3><a name="431">4.3.1</a> Message VERSION</h3>
	
	<p>Commande: VERSION<br>
	Paramètres: [&lt;serveur&gt;]
	<p>
	Le message VERSION est utilisé pour déterminer
	la version du programme serveur. Un paramètre optionnel
	&lt;serveur&gt; est utilisé pour obtenir la version d'un
	programme serveur sur lequel un client n'est pas connecté
	directement.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER                RPL_VERSION
	</pre>
	<p>Exemples:
	<ul>
	<tt>:Wiz VERSION *.se</tt>               ; message de Wiz
	pour vérifier la version d'un serveur correspondant à
	"*.se"<br>
	
	<tt>VERSION tolsun.oulu.fi</tt>          ; vérifie
	la version du serveur "tolsun.oulu.fi".<br>
	</ul>
	
	<h3><a name="432">4.3.2</a> Message STATS</h3>
	
	<p>Commande: STATS<br>
	Paramètres: [&lt;requête&gt; [&lt;serveur&gt;]]
	
	<p>
	Le message STATS est utilisé pour obtenir
	les statistiques d'un serveur. Si le paramètre &lt;serveur&gt;
	est omis, seule la fin de la réponse STATS est renvoyée.
	L'implémentation de cette requête dépend énormément
	du serveur qui répond. Néanmoins, le serveur doit
	être capable de fournir les informations décrites
	dans les requêtes ci-dessous (ou équivalent).
	<p>
	Une requête peut être lancée par
	une unique lettre, qui est vérifiée uniquement par
	le serveur destination (si le paramètre &lt;serveur&gt;
	est présent). Elle est transmise aux serveurs intermédiaires,
	ignorée et inaltérée. Les requêtes
	suivantes sont celles trouvées dans les implémentations
	courantes d'IRC, et fournissent une grande partie des informations
	de configuration du serveur. Bien qu'elles ne soient pas nécessairement
	gérées de la même façon par d'autres
	versions, tous les serveurs devraient être capables de fournir
	une réponse valide à la requête STATS, qui
	soit compatible avec les formats de réponse actuellement
	utilisées et le but de ces requêtes.
	<p>
	Les requêtes actuellement gérées
	sont : <br>
	
	c - renvoie la liste des serveurs qui peuvent se
	connecter, ou dont les connexions sont acceptées ;
	<br>
	h - renvoie la liste des serveurs qui sont forcés
	de se comporter comme des feuilles(L) , ou comme des noeuds (H)
	sur l'arbre des connexions ;
	<br>
	i - renvoie la liste des hôtes dont le serveur
	accepte les clients ;
	<br>
	k - retourne la liste des combinaisons de noms d'utilisateurs
	/ noms d'hôtes qui sont bannis de ce serveur.
	<br>
	l - renvoie la liste des connexions d'un serveur,
	et montre, pour chacune d'entre elles, le trafic en octets et en
	messages, et ce, dans chaque direction ;
	<br>
	m - renvoie la liste des commandes gérées
	par le serveur, et le nombre d'utilisations de chacune d'entre
	elles, s'il n'est pas nul ;
	<br>
	o - renvoie la liste des hôtes depuis lesquels
	un client normal peut devenir opérateur ;
	<br>
	y - montre les lignes Y (Classe) du fichier de configuration
	du serveur ;
	<br>
	u - renvoie une chaîne décrivant depuis
	combien de temps le serveur fonctionne.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER
			   RPL_STATSCLINE                  RPL_STATSNLINE
			   RPL_STATSILINE                  RPL_STATSKLINE
			   RPL_STATSQLINE                  RPL_STATSLLINE
			   RPL_STATSLINKINFO               RPL_STATSUPTIME
			   RPL_STATSCOMMANDS               RPL_STATSOLINE
			   RPL_STATSHLINE                  RPL_ENDOFSTATS
	</Pre>
	<p>Exemples:
	<ul>
	<tt>STATS m</tt>
	; vérifie l'utilisation des commandes pour
	le serveur sur lequel vous êtes connecté.<br>
	
	<tt>:Wiz STATS c eff.org</tt>            ; requête de
	WiZ pour information sur les lignes C/N du serveur eff.org
	
	</ul>
	
	<h3><a name="433">4.3.3</a> Message LINKS</h3>
	
	<p>Commande: LINKS<br>
	Paramètres: [[&lt;serveur distant&gt;] &lt;masque
	de serveur &gt;]
	<p>
	Avec LINKS, un utilisateur peut obtenir la liste
	des serveurs connue d'un serveur. La liste des serveurs doit correspondre
	au masque, ou s'il n'y a pas de masque, la liste complète
	des serveurs est renvoyée.
	<p>
	Si le &lt;serveur distant&gt; est fourni, en plus
	du &lt;masque de serveur&gt;, la commande LINKS est transmise
	au premier serveur trouvé dont le nom correspond (s'il
	y en a), et ce serveur doit alors répondre à la
	requête.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER
			   RPL_LINKS                       RPL_ENDOFLINKS
	</pre>
	<p>Exemples:
	<ul>
	<tt>LINKS *.au</tt>                      ; liste tous les
	serveurs dont le nom correspond  à *.au;<br>
	
	<tt>:WiZ LINKS *.bu.edu *.edu</tt>       ; message LINKS de
	WiZ au premier serveur correspondant à *.edu demandant
	la liste des serveurs correspondant à *.bu.edu.<br>
	</ul>
	
	<h3><a name="434">4.3.4</a> Message TIME</h3>
	
	<p>Commande: TIME<br>
	Paramètres: [&lt;serveur&gt;]
	<p>
	Le message TIME est utilisé pour obtenir l'heure
	locale d'un serveur donné. En absence de paramètre
	&lt;serveur&gt;, le serveur recevant le message doit répondre
	à la requête.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER                RPL_TIME
	</pre>
	<p>Exemples:
	<ul>
	<tt>TIME tolsun.oulu.fi</tt>             ; demande l'heure
	du serveur "tolson.oulu.fi"<br>
	
	<tt>Angel TIME *.au</tt>                 ; L'utilisateur
	Angel demande l'heure à un serveur correspondant à
	"*.au"
	
	</ul>
	
	<h3><a name="435">4.3.5</a> Message CONNECT</h3>
	
	<p>Commande: CONNECT<br>
	Paramètres: &lt;serveur destination &gt; [&lt;port&gt;
	[&lt;serveur distant&gt;]]
	<p>
	Le message CONNECT est utilisé pour forcer
	un serveur à essayer d'établir immédiatement
	une nouvelle connexion à un autre serveur. CONNECT est
	une commande privilégiée et n'est accessible qu'aux
	opérateurs IRC. Si un serveur distant est précisé,
	alors ce serveur tente de se connecter au &lt;serveur distant&gt;,
	sur le &lt;port&gt; donné.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER                ERR_NOPRIVILEGES
			   ERR_NEEDMOREPARAMS<br>
	</Pre>
	<p>Exemples:<br>
	<ul>
	<tt>CONNECT tolsun.oulu.fi</tt>          ; Essai de connexion
	au serveur tolsun.oulu.fi<br>
	
	<tt>:WiZ CONNECT eff.org 6667 csd.bu.edu</tt>
	; essai de CONNECT de WiZ pour lier eff.org et csd.bu.edu
	sur le port 6667.<br>
	
	</ul>
	
	<h3><a name="436">4.3.6</a> Message TRACE</h3>
	
	<p>Commande: TRACE<br>
	Paramètres: [&lt;serveur&gt;]
	<p>
	La commande TRACE est utilisée pour trouver
	une route vers un serveur donné. Chaque serveur qui traite
	ce message doit répondre à l'expéditeur en
	indiquant qu'il est un lien sur le chemin d'acheminement, formant
	ainsi une chaîne de réponse similaire à celle
	obtenue par un "traceroute". Après avoir renvoyé
	sa réponse, il doit ensuite envoyer le message TRACE au
	serveur suivant, et ce jusqu'à ce que le serveur spécifié
	soit atteint. Si le paramètre &lt;serveur&gt; est omis,
	il est recommandé que la commande trace envoie un message
	à l'expéditeur lui disant à quels serveurs
	il est directement connecté.
	<p>
	Si la destination spécifiée par &lt;serveur&gt;
	est en fait un serveur, alors le serveur destinataire doit lister
	tous les serveurs et les utilisateurs qui y sont connectés.
	Si la destination spécifiée par &lt;serveur&gt;
	est en fait un pseudonyme, seule la réponse pour ce pseudonyme
	est donnée.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER<br>
	</Pre>
	<p>Si le message TRACE est destiné à un
	autre serveur, tous les serveurs intermédiaires doivent
	retourner une réponse RPL_TRACELINK pour indiquer que le
	TRACE est passé par lui et où il va ensuite.<br>
	
	<Pre>
			   RPL_TRACELINK<br>
	
	</Pre>
	<p>Une réponse TRACE doit être une des
	réponses numériques suivantes :<br>
	
	<Pre>
			   RPL_TRACECONNECTING             RPL_TRACEHANDSHAKE
			   RPL_TRACEUNKNOWN                RPL_TRACEOPERATOR
			   RPL_TRACEUSER                   RPL_TRACESERVER
			   RPL_TRACESERVICE                RPL_TRACENEWTYPE
			   RPL_TRACECLASS<br>
	</Pre>
	<p>Exemples:
	<ul>
	<tt>TRACE *.oulu.fi</tt>                 ; TRACE un serveur
	correspondant à *.oulu.fi<br>
	
	<tt>:WiZ TRACE AngelDust</tt>            ; TRACE de WiZ vers
	le pseudo AngelDust
	</ul>
	
	<h3><a name="437">4.3.7</a> Commande ADMIN</h3>
	
	<p>Commande: ADMIN<br>
	Paramètres: [&lt;serveur&gt;]
	<p>
	Le message ADMIN est utilisé pour trouver
	le nom de l'administrateur d'un serveur donné, ou du serveur
	courant si le paramètre &lt;serveur&gt; est omis. Tout
	serveur doit posséder la possibilité de propager
	les messages ADMIN aux autres serveurs.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER
			   RPL_ADMINME                     RPL_ADMINLOC1
			   RPL_ADMINLOC2                   RPL_ADMINEMAIL
	</pre>
	<p>Exemples:
	<ul>
	<tt>ADMIN tolsun.oulu.fi</tt>
	; requête ADMIN de tolsun.oulu.fi<br>
	
	<tt>:WiZ ADMIN *.edu</tt>
	; requête ADMIN de WiZ pour le premier serveur
	trouvé qui correspond à *.edu.
	</ul>
	
	<h3><a name="438">4.3.8</a> Commande INFO</h3>
	
	<p>Commande: INFO<br>
	Paramètres: [&lt;serveur&gt;]
	<p>
	La commande INFO doit retourner une information qui
	décrit le serveur : sa version, quand il a été
	compilé, le numéro de mise à jour, quand
	il a été démarré, et toute autre information
	considérée comme pertinente.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER
			   RPL_INFO                        RPL_ENDOFINFO
	</pre>
	<p>Exemples:
	<ul>
	<tt>INFO csd.bu.edu</tt>                 ; requête INFO
	pour csd.bu.edu<br>
	
	<tt>:Avalon INFO *.fi</tt>               ; requête INFO
	d'Avalon à destination du premier serveur trouvé
	qui correspond à *.fi.<br>
	
	<tt>INFO Angel</tt>                      ; requête INFO
	à destination du serveur sur lequel est connecté
	Angel.
	</ul>
	
	<h2><a name="44">4.4</a>  Envoi de messages</h2>
	
	<p>Le but principal du protocole IRC est de fournir
	une base afin que des clients puissent communiquer entre eux.
	PRIVMSG et NOTICE sont les seuls messages disponibles qui réalisent
	effectivement l'acheminement d'un message textuel d'un client
	à un autre - le reste le rend juste possible et assure
	que cela se passe de façon fiable et structurée.
	
	<h3><a name="441">4.4.1</a>  Messages privés</h3>
	
	<p>Commande: PRIVMSG<br>
	Paramètres: &lt;destinataire&gt;{,&lt;destinataire&gt;}
	&lt;texte à envoyer &gt;
	<p>
	PRIVMSG est utilisé pour envoyer un message
	privé entre des utilisateurs. &lt;destinataire&gt; est
	le pseudonyme du destinataire du message. &lt;destinataire&gt;
	peut aussi être une liste de noms ou de canaux, séparés
	par des virgules.
	<p>
	Le paramètre &lt;destinataire&gt; peut aussi
	être un masque d'hôte (masque #) ou un masque de serveur
	(masque $). Le masque doit contenir au moins un (1) ".",
	et aucun joker après le dernier ".". Cette limitation
	a pour but d'empêcher les gens d'envoyer des messages à
	"#*" ou à "$*", ce qui provoquerait
	la diffusion à tous les utilisateurs ; l'expérience
	montre qu'on en abuse plus qu'on en use intelligemment, de façon
	responsable. Les jokers sont les caractères '*' et '?'.
	Ces extensions de PRIVMSG ne sont accessibles qu'aux opérateurs.
	<p>
	Réponses numériques:
	<Pre>
			   ERR_NORECIPIENT                 ERR_NOTEXTTOSEND
			   ERR_CANNOTSENDTOCHAN            ERR_NOTOPLEVEL
			   ERR_WILDTOPLEVEL                ERR_TOOMANYTARGETS
			   ERR_NOSUCHNICK
			   RPL_AWAY
	</Pre>
	<p>Exemples:
	<ul>
	<tt>:Angel PRIVMSG Wiz :Salut, est-ce que tu reçois
	ce message ?</tt>
	; Message d'Angel à Wiz.<br>
	
	<tt>PRIVMSG Angel :oui, je le reçois ! </tt>
	; Message à Angel.<br>
	
	<tt>PRIVMSG jto@tolsun.oulu.fi :Hello !</tt>
	; Message à un client du serveur tolsun.oulu.fi
	dont le nom est "jto".<br>
	
	<tt>PRIVMSG $*.fi :Server tolsun.oulu.fi rebooting.</tt>
	; Message à tous sur les serveurs dont les
	noms correspondent à *.fi.<br>
	
	<tt>PRIVMSG #*.edu :NSFNet is undergoing work, expect
	interruptions</tt>
	; Message à tous les utilisateurs qui viennent
	d'un hôte dont le nom correspond à *.edu.<br>
	</ul>
	
	<h3><a name="442">4.4.2</a> Notice</h3>
	
	<p>Commande: NOTICE<br>
	Paramètres: &lt;pseudonyme&gt; &lt;texte&gt;
	
	<p>
	Le message NOTICE s'utilise de la même façon
	que PRIVMSG. La différence entre NOTICE et PRIVMSG est
	qu'aucune réponse automatique ne doit être envoyée
	en réponse à un message NOTICE. Ceci est aussi valable
	pour les serveurs - ils ne doivent pas renvoyer de message d'erreur
	à la réception d'un message NOTICE. Le but de cette
	règle est d'éviter les boucles entre les clients
	qui enverraient automatiquement quelque chose en réponse
	à une requête. Cela est typiquement utilisé
	par des automates (des clients qui ont une intelligence artificielle
	ou un autre programme interactif contrôlant leurs actions)
	qui répondent systématiquement aux réponses
	d'autres automates.
	<p>
	Voir PRIVMSG pour les détails sur les réponses,
	et pour les exemples.
	
	<h2><a name="45">4.5</a>  Requêtes basées sur les utilisateurs</h2>
	
	<p>Les requêtes utilisateurs sont un groupe de
	commandes dont le but principal est la recherche d'informations
	sur un utilisateur particulier, ou sur un groupe d'utilisateurs.
	Lorsqu'on utilise des jokers avec ces commandes, elles ne renvoient
	les informations que sur les utilisateurs qui vous sont 'visibles'.
	La visibilité d'un utilisateur est déterminée
	par la combinaison du mode de cet utilisateur, et des canaux sur
	lesquels tous les deux êtes.
	
	<h3><a name="451">4.5.1</a>  Requête WHO</h3>
	
	<p>Commande: WHO<br>
	Paramètres: [&lt;nom&gt; [&lt;o&gt;]]
	<p>
	Le message WHO est utilisé par un client pour
	générer une requête qui renvoie une liste
	d'informations qui correspondent au paramètre &lt;nom&gt;
	donné par le client. Si le paramètre nom est absent,
	tous les utilisateurs visibles (ceux qui ne
	sont pas invisibles (mode utilisateur +i) et qui n'ont pas de canal
	en commun avec le client émettant la requête) sont listés. Le
	même résultat peut être obtenu en utilisant
	le &lt;nom&gt; "0" ou tout joker correspondant à
	toutes les entrées possibles.
	<p>
	Le &lt;nom&gt; passé en paramètre est
	mis en correspondance avec les hôtes des utilisateurs, leurs
	véritables noms, et leurs pseudonymes si le canal &lt;nom&gt;
	n'est pas trouvé.
	<p>
	Si le paramètre "o" est passé,
	seuls les opérateurs sont listés, et ce, en fonction
	du masque fourni.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER
			   RPL_WHOREPLY                    RPL_ENDOFWHO
	</pre>
	<p>Exemples:
	<ul>
	<tt>WHO *.fi</tt>
	; Liste tous les utilisateurs qui correspondent à
	"*.fi".<br>
	
	<tt>WHO jto* o</tt>
	; Liste tous les utilisateurs qui correspondent à
	"jto*", s'ils sont opérateurs.<br>
	</ul>
	
	<h3><a name="452">4.5.2</a>  Requête WHOIS</h3>
	
	<p>Commande: WHOIS<br>
	Paramètres: [&lt;serveur&gt;] &lt;masque de
	pseudo&gt;[,&lt;masque de pseudo&gt;[,...]]
	<p>
	Ce message est utilisé pour obtenir des informations
	sur un utilisateur donné. Le serveur répondra à
	ce message avec des messages numériques indiquant les différents
	statuts de chacun des utilisateurs qui correspondent au &lt;masque
	de pseudo&gt; (si vous pouvez les voir). S'il n'y a pas de joker
	dans le &lt;masque de pseudo&gt;, toutes les informations auxquelles
	vous avez accès au sujet de ce pseudo seront présentées.
	On peut séparer la liste des pseudonymes avec une virgule
	(',').
	<p>
	La dernière version envoie une requête
	à un serveur spécifique. C'est utile si vous voulez
	savoir depuis combien de temps l'utilisateur concerné a
	été oisif, car seul le serveur local (celui auquel
	cet utilisateur est directement connecté) connaît
	cette information, alors que tout le reste est connu par tous
	les serveurs.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER                ERR_NONICKNAMEGIVEN
			   RPL_WHOISUSER                   RPL_WHOISCHANNELS
			   RPL_WHOISCHANNELS               RPL_WHOISSERVER
			   RPL_AWAY                        RPL_WHOISOPERATOR
			   RPL_WHOISIDLE                   ERR_NOSUCHNICK
			   RPL_ENDOFWHOIS<br>
	</Pre>
	<p>Exemples:
	<ul>
	<tt>WHOIS wiz</tt>
	; renvoie les informations disponibles sur le pseudo WiZ<br>
	
	<tt>WHOIS eff.org trillian</tt>
	; demande au serveur eff.org les informations concernant trillian<br>
	</ul>
	
	<h3><a name="453">4.5.3</a> WHOWAS</h3>
	
	<p>Commande: WHOWAS<br>
	Paramètres: &lt;pseudonyme&gt; [&lt;compte&gt;
	[&lt;serveur&gt;]]
	<p>
	WHOWAS permet de demander des informations concernant
	un utilisateur qui n'existe plus. Cela peut être dû
	à un changement de pseudonyme ou au fait que l'utilisateur
	ait quitté l'IRC. En réponse à cette requête,
	le serveur cherche un pseudo correspondant dans l'historique des
	pseudonymes (sans utiliser de jokers). L'historique est parcouru
	à l'envers, de façon à renvoyer l'entrée
	la plus récente en premier. S'il y a plusieurs entrées,
	jusqu'à &lt;compte&gt; entrées seront retournées
	(ou toutes si le paramètre &lt;compte&gt; n'est pas donné).
	Si le nombre passé n'est pas positif, une recherche complète
	a lieu.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NONICKNAMEGIVEN             ERR_WASNOSUCHNICK
			   RPL_WHOWASUSER                  RPL_WHOISSERVER
			   RPL_ENDOFWHOWAS
	</Pre>
	<p>Exemples:
	<ul>
	<tt>WHOWAS Wiz</tt>
	; renvoie toutes les informations dans l'historique
	des pseudos au sujet du pseudo "WiZ";<br>
	
	<tt>WHOWAS Mermaid 9</tt>
	; renvoie, au maximum, les neufs entrées les
	plus récentes dans l'historique des pseudos pour "Mermaid";
	<br>
	
	<tt>WHOWAS Trillian 1 *.edu</tt>
	; demande l'entrée la plus récente
	pour "Trillian" au premier serveur trouvé qui
	correspond à "*.edu".
	</ul>
	
	<h2><a name="46">4.6</a>  Messages divers</h2>
	
	<p>Les messages de cette catégorie ne font partie
	d'aucune des catégories ci-dessus, mais font néanmoins
	partie intégrante du protocole, et sont indispensables.
	
	<h3><a name="461">4.6.1</a> Message KILL</h3>
	
	<p>Commande: KILL<br>
	Paramètres: &lt;pseudonyme&gt; &lt;commentaire&gt;
	
	<p>
	Le message KILL est utilisé pour provoquer
	la fermeture de la connexion client/serveur par le serveur qui
	gère cette connexion. KILL est aussi utilisé par
	les serveurs qui rencontrent un doublon dans la liste des entrées
	de pseudonymes valides, afin de retirer les deux entrées.
	Elle est également accessible aux opérateurs.
	<p>
	Les clients qui ont des reconnexions automatiques
	rendent cette commande inefficace, car la déconnexion est
	brève. Cela permet tout de même d'interrompre un
	flux de données et est utile pour arrêter un flux
	abusif (trop important). Tout utilisateur peut demander à
	recevoir les messages KILL générés pour d'autres
	clients afin de garder un oeil sur les fauteurs de trouble
	éventuels.
	<p>
	Dans une arène où les pseudonymes doivent
	être globalement uniques, les messages KILL sont envoyés
	à chaque fois qu'un doublon est détecté (c'est-à-dire
	une tentative d'enregistrer deux utilisateurs avec le même
	pseudonyme) dans l'espoir qu'ils disparaîtront tous les
	deux, et qu'un seul réapparaîtra.
	<p>
	Le commentaire doit refléter la véritable
	raison du KILL. Pour les messages issus de serveurs, il est
	habituellement constitué des détails concernant
	les origines des deux pseudonymes en conflit. Les utilisateurs,
	eux, sont libres de fournir une raison adéquate, de façon
	à satisfaire ceux qui le voient. Afin de prévenir/d'éviter
	des KILL maquillés pour cacher l'identité de l'auteur
	d'être générés, le commentaire contient
	également un 'chemin de KILL' qui est mis à jour
	par tous les serveurs par lequel il passe, chacun ajoutant son
	nom au chemin.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOPRIVILEGES                ERR_NEEDMOREPARAMS
			   ERR_NOSUCHNICK                  ERR_CANTKILLSERVER
	</Pre>
	<p>Exemple:
	<ul>
	<tt>KILL David (csd.bu.edu &lt;- tolsun.oulu.fi)</tt>
	; Collision de pseudonymes entre csd.bu.edu et tolson.oulu.fi
	</ul>
	
	<p>
	NOTE:<br>
	Il est recommandé que seuls les opérateurs
	soient autorisés à déconnecter d'autres utilisateurs
	avec un message KILL. Dans un monde parfait, même les opérateurs
	ne devraient pas avoir besoin de cette commande, et on laisserait
	les serveurs se débrouiller.
	
	<h3><a name="462">4.6.2</a> Message PING</h3>
	
	<p>Commande: PING<br>
	Paramètres: &lt;serveur1&gt; [&lt;serveur2&gt;]
	
	<p>
	Le message PING est utilisé pour tester la
	présence d'un client actif à l'autre bout de la
	connexion. Un message PING est envoyé régulièrement
	si aucune activité n'est détectée sur une
	connexion. Si la connexion ne répond pas à la
	commande PING dans un certain délai, la connexion est
	fermée.
	<p>
	Tout client qui reçoit un message PING doit
	répondre au &lt;serveur1&gt; (serveur qui a envoyé
	le message PING) aussi rapidement que possible, avec un message
	PONG approprié pour indiquer qu'il est toujours là
	et actif. Les serveurs ne doivent pas répondre aux commandes
	PING, mais se fier au PING dans l'autre sens pour indiquer que
	la connexion est toujours active. Si le paramètre &lt;serveur2&gt;
	est spécifié, le message PING lui est transmis.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOORIGIN                    ERR_NOSUCHSERVER
	</pre>
	<p>Exemples:
	<ul>
	<tt>PING tolsun.oulu.fi</tt>
	; serveur envoyant un message PING à un autre
	serveur pour indiquer qu'il est toujours actif.<br>
	
	<tt>PING WiZ</tt>
	; message PING envoyé au pseudo WiZ<br>
	</ul>
	
	<h3><a name="463">4.6.3</a> Message PONG</h3>
	
	<p>Commande: PONG<br>
	Paramètres: &lt;démon&gt; [&lt;démon2&gt;]
	
	<p>
	Le message PONG est la réponse à un
	message PING. Si le paramètre &lt;démon2&gt; est
	donné, le message doit être transmis au démon
	donné. Le paramètre &lt;démon&gt; est le
	nom du démon responsable du message PING généré.
	
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOORIGIN                    ERR_NOSUCHSERVER
	</pre>
	<p>Exemples:
	<ul>
	<tt>PONG csd.bu.edu tolsun.oulu.fi</tt>
	; message PONG de csd.bu.edu à tolsun.oulu.fi
	</ul>
	
	<h3><a name="464">4.6.4</a> Message ERROR</h3>
	
	<p>Commande: ERROR<br>
	Paramètres: &lt; message d'erreur&gt;
	<p>
	La commande ERROR est utilisée par les serveurs
	pour rapporter une erreur sérieuse ou fatale à ses
	opérateurs. Elle peut aussi être envoyée d'un
	serveur à un autre, mais ne doit pas être acceptée
	de simples clients inconnus.
	<p>
	Un message ERROR ne doit être utilisé
	que pour annoncer les erreurs qui ont lieu sur un lien serveur/serveur.
	Un message ERROR est envoyé au serveur associé (qui
	le transmet à tous ses opérateurs connectés)
	et à tous les opérateurs connectés. Il ne
	doit pas être transmis aux autres serveurs s'il est reçu
	d'un serveur.
	<p>
	Quand un serveur transmet un message ERROR à
	ses opérateurs, le message doit être encapsulé
	dans un message NOTICE, en indiquant que le client n'est pas responsable
	de l'erreur.
	<p>
	Réponses numériques :
	<Pre>
			   Aucune.
	</Pre>
	<p>Exemples:
	<ul>
	<tt>ERROR :Server *.fi already exists</tt>
	; message ERROR à l'autre serveur qui a provoqué
	cette erreur.<br>
	
	<tt>NOTICE WiZ :ERROR from csd.bu.edu -- Server *.fi already exists</tt>
	; Même message ERROR qu'au dessus, mais envoyé
	à l'utilisateur Wiz sur l'autre serveur.
	</ul>
	
	<h1><a name="5">5.</a> Messages optionnels</h1>
	
	<p>Cette section décrit les messages optionnels.
	Ils ne sont pas requis dans les implémentations des serveurs
	décrits ici. En l'absence de l'option, un message d'erreur
	doit être généré, ou une erreur commande
	inconnue. Si le message est destiné à un autre serveur,
	il doit être transmis (traitement de base obligatoire). Les nombres
	alloués pour cela sont listés avec les messages ci-dessous.
	
	<h2><a name="51">5.1</a> AWAY</h2>
	
	<p>Commande: AWAY<br>
	Paramètres: [message]
	<p>
	Avec le message AWAY, les clients peuvent définir
	une chaîne de réponse automatique pour toute commande
	PRIVMSG qui leur est destinée (et non pas à un canal
	sur lequel ils sont). La réponse est envoyée directement
	par le serveur au client envoyant une commande PRIVMSG. Le seul
	serveur à répondre est celui sur lequel le client
	émetteur est situé.
	<p>
	Le message AWAY est utilisé soit avec un paramètre
	(pour définir un message AWAY) ou sans (pour retirer le
	message AWAY).
	<p>
	Réponses numériques :
	<Pre>
			   RPL_UNAWAY                      RPL_NOWAWAY
	</pre>
	<p>Exemples:
	<ul>
	<tt>AWAY :Parti déjeuner. De retour à 2 heures.</tt>
	; définit le message d'absence en "Parti
	déjeuner. De retour à 2 heures.".<br>
	
	<tt>:WiZ AWAY</tt>
	; supprime l'absence de WiZ.<br>
	</ul>
	
	<h2><a name="52">5.2</a> Message REHASH</h2>
	
	<p>Commande: REHASH<br>
	Paramètres: Aucun
	<p>
	Le massage REHASH  est utilisé par les opérateurs
	pour forcer un serveur à relire et traiter son fichier
	de configuration.
	<p>
	Réponses numériques :
	<Pre>
			RPL_REHASHING                   ERR_NOPRIVILEGES
	</pre>
	<p>Exemples:
	<ul>
	<tt>REHASH</tt>
	; message d'un client
	ayant un statut d'opérateur au serveur, lui demandant de
	relire son fichier de configuration.
	</ul>
	
	<h2><a name="53">5.3</a> Message RESTART</h2>
	
	<p>Commande: RESTART<br>
	Paramètres: Aucun
	<p>
	Le message RESTART n'est utilisable que par un opérateur.
	Il sert à redémarrer le serveur. La gestion de ce
	message est optionnelle, car il est risqué de permettre
	à des personnes se connectant comme opérateur d'exécuter
	cette commande, qui cause une interruption de service (au moins).
	
	<p>
	La commande RESTART doit toujours être traitée
	par le serveur qui la reçoit, et non passée à
	un autre serveur.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOPRIVILEGES
	</Pre>
	<p>Exemples:
	<ul>
	<tt>RESTART</tt>
	; pas de paramètres
	</ul>
	
	<h2><a name="54">5.4</a> Message SUMMON</h2>
	
	<p>Commande: SUMMON<br>
	Paramètres: &lt;utilisateur&gt; [&lt;serveur&gt;]
	
	<p>
	La commande SUMMON peut être utilisée
	pour envoyer à des utilisateurs qui sont sur l'hôte
	sur lequel s'exécute le serveur IRC un message leur demandant
	de joindre l'IRC. Ce message ne peut être envoyé
	que si le serveur (a) a la commande SUMMON activée, et
	(b) si le processus serveur peut écrire sur le tty (ou
	similaire) de l'utilisateur.
	<p>
	Si le paramètre &lt;serveur&gt; n'est pas
	donné, cela essaie d'appeler l'&lt;utilisateur&gt; du serveur
	sur lequel le client est connecté.
	<p>
	Si le SUMMON est désactivé sur un serveur,
	il doit renvoyer la réponse numérique ERR_SUMMONDISABLED
	et transmettre le message SUMMON.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NORECIPIENT                 ERR_FILEERROR
			   ERR_NOLOGIN                     ERR_NOSUCHSERVER
			   RPL_SUMMONING<br>
	</Pre>
	<p>Exemples:
	<ul>
	<tt>SUMMON jto</tt>
	; appelle l'utilisateur jto sur l'hôte du serveur<br>
	
	<tt>SUMMON jto tolsun.oulu.fi</tt>
	; appelle l'utilisateur
	jto sur l'hôte sur lequel le serveur "tolsun.oulu.fi"
	est lancé.
	</ul>
	
	<h2><a name="55">5.5</a> Commande USERS</h2>
	
	<p>Commande: USERS<br>
	Paramètres: [&lt;serveur&gt;]
	<p>
	La commande USERS fonctionne de façon similaire
	à WHO(1), RUSERS(1) et FINGER(1). Certains peuvent désactiver
	cette commande sur leur serveur pour des raisons de sécurité.
	En cas de désactivation, cela doit être indiqué
	par le retour de réponse numérique appropriée.
	
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NOSUCHSERVER                ERR_FILEERROR
			   RPL_USERSSTART                  RPL_USERS
			   RPL_NOUSERS                     RPL_ENDOFUSERS
			   ERR_USERSDISABLED<br>
	</Pre>
	<p>Réponse de désactivation :
	<Pre>
			   ERR_USERSDISABLED<br>
	</Pre>
	<p>Exemples:
	<ul>
	<tt>USERS eff.org </tt>
	; requiert la liste des utilisateurs connectés
	au serveur eff.org<br>
	
	<tt>:John USERS tolsun.oulu.fi</tt>
	; requête de John pour obtenir la liste des
	utilisateurs du serveur tolsun.oulu.fi
	
	</ul>
	
	<h2><a name="56">5.6</a> Message WALLOPS</h2>
	
	<p>Commande: WALLOPS<br>
	Paramètres: Texte à envoyer à
	tous les opérateurs actuellement connectés.
	<p>
	Envoie un message à tous les opérateurs
	actuellement connectés. Après avoir essayé
	de laisser accès à cette commande à tous
	les utilisateurs, il a été constaté qu'on
	en abusait comme un moyen d'envoyer des messages à plein
	de personnes (comme WALL). A cause de cela, il est recommandé
	que l'implémentation courante de WALLOPS ne reconnaisse
	que les serveurs comme émetteurs de WALLOPS.
	<p>
	Réponses numériques :
	<Pre>
			   ERR_NEEDMOREPARAMS
	</Pre>
	<p>Exemples:
	<ul>
	<tt>:csd.bu.edu WALLOPS :Connect '*.uiuc.edu 6667' from Joshua</tt>
	; message WALLOPS de csd.bu.edu  annonçant
	un message CONNECT reçu et traité, issu de Joshua.
	</ul>
	
	<h2><a name="57">5.7</a> Message USERHOST</h2>
	
	<p>Commande: USERHOST<br>
	Paramètres: &lt;pseudonyme&gt;{&lt;espace
	&gt;&lt;pseudonyme&gt;}
	<p>
	La commande USERHOST prend jusqu'à 5 pseudonymes,
	séparés par des virgules, et renvoie une liste d'informations
	pour chacun des pseudonymes qu'il a trouvés. La liste des
	réponses contient chaque réponse séparée
	par des espaces.
	<p>
	Réponses numériques :
	<Pre>
			   RPL_USERHOST                    ERR_NEEDMOREPARAMS
	</pre>
	<p>Exemples:
	<ul>
	<tt>USERHOST Wiz Michael Marty p</tt>
	;requête USERHOST pour information sur les
	pseudos "Wiz", "Michael", "Marty"
	et "p"
	</ul>
	
	<h2><a name="58">5.8</a> Message ISON</h2>
	
	<p>Commande: ISON<br>
	Paramètres: &lt;pseudonyme&gt;{&lt;espace&gt;&lt;pseudonyme&gt;}
	
	<p>
	La commande ISON a été implémentée
	pour fournir une manière rapide et efficace de savoir si
	un pseudonyme donné est connecté à l'IRC.
	ISON prend un (1) paramètre : une liste de pseudonymes
	séparés par des espaces. Chaque pseudonyme présent
	est ajouté à la chaîne de réponse du
	serveur. Ainsi, la chaîne de réponse peut être
	vide (aucun utilisateur n'est présent), une copie exacte
	de la chaîne de caractères passée en paramètres
	(ils sont tous présents), ou un sous-ensemble du groupe
	de pseudonymes passé en paramètre. La seule limite
	au nombre de pseudos qui peuvent être testés est
	la troncature des commandes à une longueur de 512 caractères.
	
	<p>
	ISON n'est traitée que par le serveur local
	au client effectuant la requête, et n'est donc pas passée
	pour traitement aux autres serveurs
	<p>
	Réponses numériques :
	<pre>
			   RPL_ISON                ERR_NEEDMOREPARAMS
	</pre>
	<p>Exemples:
	<ul>
	<tt>ISON phone trillian WiZ jarlek Avalon Angel Monstah</tt>
	; Exemple de requête ISON pour 7 pseudonymes
	</ul>
	
	<h1><a name="6">6.</a> Réponses</h1>
	
	<p>Ce qui suit est une liste de réponses numériques
	générées à la suite des commandes
	spécifiées ci-dessus. Chaque réponse numérique
	est donnée avec son numéro, son nom, et sa chaîne
	de réponse (en anglais).
	
	<h2><a name="61">6.1</a> Réponses d'erreur</h2>
	
	<dl>
	<dt>401     ERR_NOSUCHNICK
	<dd>"&lt;pseudonyme&gt; :No such nick/channel"
	</dl>
	<p>Utilisé pour indiquer que le pseudonyme passé
	en paramètre à la commande n'est pas actuellement
	utilisé.
	
	<dl>
	<dt>402     ERR_NOSUCHSERVER
	<dd>"&lt;nom de serveur&gt; :No such server"
	</dl>
	<p>Utilisé pour indiquer que le nom du serveur
	donné n'existe pas actuellement.
	
	<dl>
	<dt>403     ERR_NOSUCHCHANNEL
	<dd>"&lt;nom de canal&gt; :No such channel"
	</dl>
	<p>Utilisé pour indiquer que le nom de canal
	donné est invalide.
	
	<dl>
	<dt>404     ERR_CANNOTSENDTOCHAN
	<dd>"&lt;nom de canal&gt; :Cannot send to channel"
	</dl>
	<p>Envoyé à un utilisateur qui (a) soit
	n'est pas dans un canal en mode +n ou (b) n'est pas opérateur
	(ou mode +v) sur un canal en mode +m ; et essaie d'envoyer un
	PRIVMSG à ce canal.
	
	<dl>
	<dt>405     ERR_TOOMANYCHANNELS
	<dd>"&lt;nom de canal&gt; :You have joined too many channels"
	</dl>
	<p>Envoyé à un utilisateur quand il a
	atteint le nombre maximal de canaux qu'il est autorisé
	à accéder simultanément, s'il essaie
	d'en rejoindre un autre.
	
	<dl>
	<dt>406     ERR_WASNOSUCHNICK
	<dd>"&lt;nom de canal&gt;
	:There was no such nickname"
	</dl>
	<p>Renvoyé par WHOWAS pour indiquer qu'il n'y
	a pas d'information dans l'historique concernant ce pseudonyme.
	
	<dl>
	<dt>407     ERR_TOOMANYTARGETS
	<dd>"&lt;destination&gt;
	:Duplicate recipients. No message delivered"
	</dl>
	<p>Renvoyé à un client qui essaie d'envoyer
	un PRIVMSG/NOTICE utilisant le format de destination utilisateur@hôte
	pour lequel utilisateur@hôte a plusieurs occurrences.
	
	<dl>
	<dt>409     ERR_NOORIGIN
	<dd>":No origin specified"
	</dl>
	<p>Message PING ou PONG sans le paramètre origine
	qui est obligatoire puisque ces commandes doivent marcher sans
	préfixe.
	
	<dl>
	<dt>411     ERR_NORECIPIENT
	<dd>":No recipient given (&lt;commande&gt;)"
	</dl>
	<p>Pas de destinataire.
	
	<dl>
	<dt>412     ERR_NOTEXTTOSEND
	<dd>":No text to send"
	</dl>
	<p>Pas de texte à envoyer.
	
	<dl>
	<dt>413     ERR_NOTOPLEVEL
	<dd>"&lt;masque&gt; :No toplevel domain specified"
	</dl>
	<p>Domaine principal non spécifié.
	
	<dl>
	<dt>414     ERR_WILDTOPLEVEL
	<dd>"&lt;masque&gt; :Wildcard in toplevel domain"
	</dl>
	<p>Joker dans le domaine principal
	
	<p>
	Les erreurs 412-414 sont renvoyées par PRIVMSG
	pour indiquer que le message n'a pas été délivré.
	ERR_NOTOPLEVEL et ERR_WILDTOPLEVEL sont les erreurs renvoyées
	lors d'une utilisation invalide de "PRIVMSG $&lt;serveur&gt;"
	ou de "PRIVMSG #&lt;hôte&gt;".
	
	<dl>
	<dt>421     ERR_UNKNOWNCOMMAND
	<dd>"&lt;commande&gt; :Unknown command"
	</dl>
	<p>Renvoyé à un client enregistré
	pour indiquer que la commande envoyée est inconnue du serveur.
	
	<dl>
	<dt>422     ERR_NOMOTD
	<dd>":MOTD File is missing"
	</dl>
	<p>Le fichier MOTD du serveur n'a pas pu être
	ouvert.
	
	<dl>
	<dt>423     ERR_NOADMININFO
	<dd>"&lt;serveur&gt; :No administrative info available"
	</dl>
	<p>Renvoyé par un serveur en réponse à
	un message ADMIN quand il y a une erreur lors de la recherche
	des informations appropriées.
	
	<dl>
	<dt>424     ERR_FILEERROR
	<dd>":File error doing &lt;opération&gt; on &lt;fichier&gt;"<br>
	</dl>
	<p>Message d'erreur générique utilisé
	pour rapporter un échec d'opération de fichier durant
	le traitement d'un message.
	
	<dl>
	<dt>431     ERR_NONICKNAMEGIVEN
	<dd>":No nickname given"
	</dl>
	<p>Renvoyé quand un paramètre pseudonyme
	attendu pour une commande n'est pas fourni.
	
	<dl>
	<dt>432     ERR_ERRONEUSNICKNAME
	<dd>"&lt;pseudo&gt; :Erroneus nickname"
	</dl>
	<p>Renvoyé après la réception d'un
	message NICK qui contient des caractères qui ne font pas
	partie du jeu autorisé. Voir les sections <a href="#1">1</a>
	et <a href="#22">2.2</a> pour les détails des pseudonymes valides.
	
	<dl>
	<dt>433     ERR_NICKNAMEINUSE
	<dd>"&lt;nick&gt; :Nickname is already in use"
	</dl>
	<p>Renvoyé quand le traitement d'un message NICK
	résulte en une tentative de changer de pseudonyme en un
	déjà existant.
	
	<dl>
	<dt>436     ERR_NICKCOLLISION
	<dd>"&lt;nick&gt; :Nickname collision KILL"
	</dl>
	<p>Renvoyé par un serveur à un client
	lorsqu'il détecte une collision de pseudonymes (enregistrement
	d'un pseudonyme qui existe déjà sur un autre serveur).
	
	<dl>
	<dt>441     ERR_USERNOTINCHANNEL
	<dd>"&lt;pseudo&gt; &lt;canal&gt; :They aren't on that channel"
	</dl>
	<p>Renvoyé par un serveur pour indiquer que l'utilisateur
	donné n'est pas dans le canal spécifié.
	
	<dl>
	<dt>442     ERR_NOTONCHANNEL
	<dd>"&lt;canal&gt; :You're not on that channel"
	</dl>
	<p>Renvoyé par le serveur quand un client essaie
	une commande affectant un canal dont il ne fait pas partie.
	
	<dl>
	<dt>443     ERR_USERONCHANNEL
	<dd>"&lt;utilisateur&gt; &lt;channel&gt; :is already on channel"
	</dl>
	<p>Renvoyé quand un client essaie d'inviter un
	utilisateur sur un canal où il est déjà.
	
	<dl>
	<dt>444     ERR_NOLOGIN
	<dd>"&lt;utilisateur&gt; :User not logged in"
	</dl>
	<p>Renvoyé par un SUMMON si la commande n'a pas
	pu être accomplie, car l'utilisateur n'est pas connecté.
	
	<dl>
	<dt>445     ERR_SUMMONDISABLED
	<dd>":SUMMON has been disabled"
	</dl>
	<p>Renvoyé en réponse à une commande
	SUMMON si le SUMMON est désactivé. Tout serveur
	qui ne gère pas les SUMMON doit retourner cette valeur.
	
	<dl>
	<dt>446     ERR_USERSDISABLED
	<dd>":USERS has been disabled"
	</dl>
	<p>Retourné en réponse à une commande
	USERS si la commande est désactivée. Tout serveur
	qui ne gère pas les USERS doit retourner cette valeur.
	
	<dl>
	<dt>451     ERR_NOTREGISTERED
	<dd>":You have not registered"
	</dl>
	<p>Retourné par le serveur pour indiquer à
	un client qu'il doit être enregistré avant que ses
	commandes soient traitées.
	
	<dl>
	<dt>461     ERR_NEEDMOREPARAMS
	<dd>"&lt;commande&gt; :Not enough parameters"
	</dl>
	<p>Renvoyé par un serveur par de nombreuses
	commandes, afin d'indiquer que le client n'a pas fourni assez
	de paramètres.
	
	<dl>
	<dt>462     ERR_ALREADYREGISTRED
	<dd>":You may not reregister"
	</dl>
	<p>Retourné par le serveur à tout lien
	qui tente de changer les détails enregistrés
	(tels que mot de passe et détails utilisateur du second
	message USER)
	
	<dl>
	<dt>463     ERR_NOPERMFORHOST
	<dd>":Your host isn't among the privileged"
	</dl>
	<p>Renvoyé à un client qui essaie de s'enregistrer
	sur un serveur qui n'accepte pas les connexions depuis cet hôte.
	
	<dl>
	<dt>464     ERR_PASSWDMISMATCH
	<dd>":Password incorrect"
	</dl>
	<p>Retourné pour indiquer l'échec d'une
	tentative d'enregistrement d'une connexion dû à
	un mot de passe incorrect ou manquant.
	
	<dl>
	<dt>465     ERR_YOUREBANNEDCREEP
	<dd>":You are banned from this server"
	</dl>
	<p>Retourné après une tentative de connexion
	et d'enregistrement sur un serveur configuré explicitement
	pour vous refuser les connexions.
	
	<dl>
	<dt>467     ERR_KEYSET
	<dd>"&lt;canal&gt; :Channel key already set"
	</dl>
	<p>Clé de canal déjà définie.
	
	<dl>
	<dt>471     ERR_CHANNELISFULL
	<dd>"&lt;canal&gt; :Cannot join channel (+l)"
	</dl>
	<p>Impossible de joindre le canal (+l)<br>
	
	<dl>
	<dt>472     ERR_UNKNOWNMODE
	<dd>"&lt;caractère&gt; :is unknown mode char to me"
	</dl>
	<p>Mode inconnu.
	
	<dl>
	<dt>473     ERR_INVITEONLYCHAN
	<dd>"&lt;canal&gt; :Cannot join channel (+i)"
	</dl>
	<p>Impossible de joindre le canal (+i).
	
	<dl>
	<dt>474     ERR_BANNEDFROMCHAN
	<dd>"&lt;canal&gt; :Cannot join channel (+b)"
	</dl>
	<p>Impossible de joindre le canal (+b).
	
	<dl>
	<dt>475     ERR_BADCHANNELKEY
	<dd>"&lt;canal&gt; :Cannot join channel (+k)"
	</dl>
	<p>Impossible de joindre le canal (+k).
	
	<dl>
	<dt>481     ERR_NOPRIVILEGES
	<dd>":Permission Denied- You're not an IRC operator"
	</dl>
	<p>Toute commande qui requiert le privilège d'opérateur
	pour opérer doit retourner cette erreur pour indiquer son
	échec.
	
	<dl>
	<dt>482     ERR_CHANOPRIVSNEEDED
	<dd>"&lt;canal&gt; :You're not channel operator"
	</dl>
	<p>Toute commande qui requiert les privilèges
	'chanop' (tels les messages MODE) doit retourner ce message
	à un client qui l'utilise sans être chanop sur le
	canal spécifié.
	
	<dl>
	<dt>483     ERR_CANTKILLSERVER
	<dd>":You cant kill a server!"
	</dl>
	<p>Toute tentative d'utiliser la commande KILL sur un
	serveur doit être refusée et cette erreur renvoyée
	directement au client.
	
	<dl>
	<dt>491     ERR_NOOPERHOST
	<dd>":No O-lines for your host"
	</dl>
	<p>Si un client envoie un message OPER et que le serveur
	n'a pas été configuré pour autoriser les
	connexions d'opérateurs de cet hôte, cette erreur
	doit être retournée.<br>
	
	<dl>
	<dt>501     ERR_UMODEUNKNOWNFLAG
	<dd>":Unknown MODE flag"
	</dl>
	<p>Renvoyé par un serveur pour indiquer que le
	message MODE a été envoyé avec un pseudonyme
	et que le mode spécifié n'a pas été
	identifié.
	
	<dl>
	<dt>502     ERR_USERSDONTMATCH
	<dd>":Cant change mode for other users"
	</dl>
	<p>Erreur envoyée à tout utilisateur qui
	essaie de voir ou de modifier le mode utilisateur d'un autre client.
	
	<h2><a name="62">6.2</a> Réponses aux commandes.</h2>
	
	<dl>
	<dt>300     RPL_NONE
	</dl>
	<p>Numéro de réponse bidon. Inutilisé.
	
	<dl>
	<dt>302     RPL_USERHOST
	<dd>":[&lt;réponse&gt;{&lt;espace&gt;&lt;réponse&gt;}]"
	</dl>
	<p>Format de réponse utilisé par USERHOST
	pour lister les réponses à la liste des requêtes.
	La chaîne de réponse est composée ainsi :
	<br>
	&lt;réponse&gt; ::= &lt;pseudo&gt;['*'] '='
	&lt;'+'|'-'&gt;&lt;hôte&gt;
	<br>
	Le '*' indique si le client est enregistré
	comme opérateur. Les caractères '-' ou '+' indiquent
	respectivement si le client a défini un message AWAY ou
	non.
	
	<dl>
	<dt>303     RPL_ISON
	<dd>":[&lt;pseudo&gt; {&lt;espace&gt;&lt;pseudo&gt;}]"
	</dl>
	<p>Format de réponse utilisé par ISON
	pour lister les réponses à la liste de requête.
	
	<dl>
	<dt>301     RPL_AWAY
	<dd>"&lt;pseudo&gt; :&lt;message d'absence&gt;"
	<dt>305     RPL_UNAWAY
	<dd>":You are no longer marked as being away"
	<dt>306     RPL_NOWAWAY
	<dd>":You have been marked as being away"
	</dl>
	<p>Ces trois réponses sont utilisées avec
	la commande AWAY (si elle est autorisée). RPL_AWAY est
	envoyé à tout client qui envoie un PRIVMSG à
	un client absent. RPL_AWAY n'est envoyé que par le serveur
	sur lequel le client est connecté. Les réponses
	RPL_UNAWAY et RPL_NOWAWAY sont envoyées quand un client
	retire et définit un message AWAY.<br>
	
	<dl>
	<dt>311     RPL_WHOISUSER
	<dd>"&lt;pseudo&gt; &lt;utilisateur&gt; &lt;hôte&gt; * :&lt;vrai nom&gt;"
	<dt>312     RPL_WHOISSERVER
	<dd>"&lt;pseudo&gt; &lt;serveur&gt; :&lt;info serveur&gt;"
	<dt>313     RPL_WHOISOPERATOR
	<dd>"&lt;pseudo&gt; :is an IRC operator"
	<dt>317     RPL_WHOISIDLE
	<dd>"&lt;pseudo&gt; &lt;integer&gt; :seconds idle"
	<dt>318     RPL_ENDOFWHOIS
	<dd>"&lt;pseudo&gt; :End of /WHOIS list"
	<dt>319     RPL_WHOISCHANNELS
	<dd>"&lt;pseudo&gt; :{[@|+]&lt;canal&gt;&lt;espace&gt;}"
	</dl>
	<p>Les réponses 311 à 313 et 317 à
	319 sont toutes générées en réponse
	à un message WHOIS. S'il y a assez de paramètres,
	le serveur répondant doit soit formuler une réponse
	parmi les numéros ci-dessus (si le pseudo recherché
	a été trouvé) ou renvoyer un message d'erreur.
	Le '*' dans RPL_WHOISUSER est là en tant que littéral
	et non en tant que joker. Pour chaque jeu de réponses,
	seul RPL_WHOISCHANNELS peut apparaître plusieurs fois (pour
	les longues listes de noms de canaux). Les caractères '@'
	et '+' à côté du nom de canal indiquent si un
	client est opérateur de canal, ou si on l'a autorisé
	à parler dans un canal modéré. La réponse
	RPL_ENDOFWHOIS est utilisée pour marquer la fin de la réponse
	WHOIS.
	
	<dl>
	<dt>314     RPL_WHOWASUSER
	<dd>"&lt;pseudo&gt; &lt;utilisateur&gt; &lt;hôte&gt; * :&lt;vrai nom&gt;"
	<dt>369     RPL_ENDOFWHOWAS
	<dd>"&lt;pseudo&gt; :End of WHOWAS"
	</dl>
	<p>Lorsqu'il répond à un message WHOWAS,
	un serveur doit utiliser RPL_WHOWASUSER, RPL_WHOISSERVER ou ERR_WASNOSUCHNICK
	pour chacun des pseudonymes de la liste fournie. A la fin de toutes
	les réponses, il doit y avoir un RPL_ENDOFWHOWAS (même
	s'il n'y a eu qu'une réponse, et que c'était une
	erreur).
	
	<dl>
	<dt>321     RPL_LISTSTART
	<dd>"Channel :Users  Name"
	<dt>322     RPL_LIST
	<dd>"&lt;canal&gt; &lt;# visible&gt; :&lt;sujet&gt;"
	<dt>323     RPL_LISTEND
	<dd>":End of /LIST"
	</dl>
	<p>Les réponses RPL_LISTSTART, RPL_LIST, RPL_LISTEND
	marquent le début, les réponses proprement dites,
	et la fin du traitement d'une commande LIST. S'il n'y a aucun
	canal disponible, seules les réponses de début et
	de fin sont envoyées.<br>
	
	<dl>
	<dt>324     RPL_CHANNELMODEIS
	<dd>"&lt;canal&gt; &lt;mode&gt; &lt;paramètres de mode&gt;"<br>
	<dt>331     RPL_NOTOPIC
	<dd>"&lt;canal&gt; :No topic is set"
	<dt>332     RPL_TOPIC
	<dd>"&lt;canal&gt; :&lt;sujet&gt;"
	</dl>
	<p>Lors de l'envoi d'un message TOPIC pour déterminer
	le sujet d'un canal, une de ces deux réponses est envoyée.
	Si le sujet est défini, RPL_TOPIC est renvoyée,
	sinon c'est RPL_NOTOPIC.<br>
	
	<dl>
	<dt>341     RPL_INVITING
	<dd>"&lt;canal&gt; &lt;pseudo&gt;"
	</dl>
	<p>Renvoyé par un serveur pour indiquer que le
	message INVITE a été enregistré, et est en
	cours de transmission au client final.<br>
	
	<dl>
	<dt>342     RPL_SUMMONING
	<dd>"&lt;utilisateur&gt; :Summoning user to IRC"<br>
	</dl>
	<p>Renvoyé par un serveur en réponse à
	un message SUMMON pour indiquer qu'il appelle cet utilisateur.
	
	<dl>
	<dt>351     RPL_VERSION
	<dd>"&lt;version&gt;.&lt;debuglevel&gt; &lt;serveur&gt; :&lt;commentaires&gt;"
	</dl>
	<p>Réponse du serveur indiquant les détails
	de sa version. &lt;version&gt; est la version actuelle du programme
	utilisé (comprenant le numéro de mise à jour)
	et &lt;debuglevel&gt; est utilisé pour indiquer si le serveur
	fonctionne en mode débugage.
	<br>
	Le champ &lt;commentaire&gt; peut contenir n'importe
	quel commentaire au sujet de la version, ou des détails
	supplémentaires sur la version.<br>
	
	<dl>
	<dt>352     RPL_WHOREPLY
	<dd>"&lt;canal&gt; &lt;utilisateur&gt; &lt;hôte&gt; &lt;serveur&gt; &lt;pseudo&gt; &lt;H|G&gt;[*][@|+] :&lt;compteur de distance&gt; &lt;vrai nom&gt;"
	<dt>315     RPL_ENDOFWHO
	<dd>"&lt;nom&gt; :End of /WHO list"
	</dl>
	<p>La paire RPL_WHOREPLY et RPL_ENDOFWHO est utilisée
	en réponse à un message WHO. Le RPL_WHOREPLY n'est
	envoyé que s'il y a une correspondance à la requête
	WHO. S'il y a une liste de paramètres fournie avec le message
	WHO, un RPL_ENDOFWHO doit être envoyé après
	le traitement de chaque élément de la liste, &lt;nom&gt;
	étant l'élément.
	
	<dl>
	<dt>353     RPL_NAMREPLY
	<dd>"&lt;canal&gt; :[[@|+]&lt;pseudo&gt; [[@|+]&lt;pseudo&gt; [...]]]"
	<dt>366     RPL_ENDOFNAMES
	<dd>"&lt;canal&gt; :End of /NAMES list"
	</dl>
	<p>En réponse à un message NAMES, une
	paire consistant de RPL_NAMREPLY et RPL_ENDOFNAMES est renvoyée
	par le serveur au client. S'il n'y a pas de canal résultant
	de la requête, seul RPL_ENDOFNAMES est retourné.
	L'exception à cela est lorsqu'un message NAMES est envoyé
	sans paramètre et que tous les canaux et contenus visibles
	sont renvoyés en une suite de message RPL_NAMEREPLY avec
	un RPL_ENDOFNAMES indiquant la fin.
	
	<dl>
	<dt>364     RPL_LINKS
	<dd>"&lt;masque&gt; &lt;serveur&gt; :&lt;compteur de distance&gt; &lt;info serveur&gt;"
	<dt>365     RPL_ENDOFLINKS
	<dd>"&lt;mask&gt; :End of /LINKS list"
	</dl>
	<p>En réponse à un message LINKS, un serveur
	doit répondre en utilisant le nombre RPL_LINKS, et indiquer
	la fin de la liste avec une réponse RPL_ENDOFLINKS.<br>
	
	<dl>
	<dt>367     RPL_BANLIST
	<dd>"&lt;canal&gt; &lt;identification de bannissement&gt;"
	<dt>368     RPL_ENDOFBANLIST
	<dd>"&lt;canal&gt; :End of channel ban list"<br>
	</dl>
	<p>Quand il liste les bannissements actifs pour un canal
	donné, un serveur doit renvoyer la liste en utilisant les
	messages RPL_BANLIST et RPL_ENDOFBANLIST. Un RPL_BANLIST différent
	doit être utilisé pour chaque identification de bannissement.
	Après avoir listé les identifications de bannissement
	(s'il y en a), un RPL_ENDOFBANLIST doit être renvoyé.
	
	<dl>
	<dt>371     RPL_INFO
	<dd>":&lt;chaîne&gt;"
	<dt>374     RPL_ENDOFINFO
	<dd>":End of /INFO list"
	</dl>
	<p>Un serveur répondant à un message INFO
	doit envoyer toute sa série d'info en une suite de réponses
	RPL_INFO, avec un RPL_ENDOFINFO pour indiquer la fin des réponses.
	
	<dl>
	<dt>375     RPL_MOTDSTART
	<dd>":- &lt;serveur&gt; Message of the day - "
	<dt>372     RPL_MOTD
	<dd>":- &lt;texte&gt;"
	<dt>376     RPL_ENDOFMOTD
	<dd>":End of /MOTD command"
	</dl>
	<p>Lorsqu'il répond à un message MOTD
	et que le fichier MOTD est trouvé, le fichier est affiché
	ligne par ligne, chaque ligne ne devant pas dépasser 80
	caractères, en utilisant des réponses au format
	RPL_MOTD. Celles-ci doivent être encadrées par un
	RPL_MOTDSTART (avant les RPL_MOTDs) et un RPL_ENDOFMOTD (après).
	
	<dl>
	<dt>381     RPL_YOUREOPER
	<dd>":You are now an IRC operator"<br>
	</dl>
	<p>RPL_YOUREOPER est renvoyé à un client
	qui vient d'émettre un message OPER et a obtenu le statut
	d'opérateur.
	
	<dl>
	<dt>382     RPL_REHASHING
	<dd>"&lt;fichier de configuration&gt; :Rehashing"
	</dl>
	<p>Si l'option REHASH est activée et qu'un opérateur
	envoie un message REHASH, un RPL_REHASHING est renvoyé
	à l'opérateur.
	
	<dl>
	<dt>391     RPL_TIME
	<dd>"&lt;serveur&gt; :&lt;chaîne indiquant l'heure locale du serveur&gt;"
	</dl>
	<p>Lorsqu'il répond à un message TIME,
	un serveur doit répondre en utilisant le format RPL_TIME
	ci-dessus. La chaîne montrant l'heure ne doit contenir que
	le jour et l'heure corrects. Il n'y a pas d'obligation supplémentaire.
	
	<dl>
	<dt>392     RPL_USERSSTART
	<dd>":UserID   Terminal  Hôte"
	<dt>393     RPL_USERS
	<dd>":%-8s %-9s %-8s"
	<dt>394     RPL_ENDOFUSERS
	<dd>":End of users"
	<dt>395     RPL_NOUSERS
	<dd>":Nobody logged in"
	</dl>
	<p>Si le message USERS est géré par un
	serveur, les réponses RPL_USERSTART, RPL_USERS, RPL_ENDOFUSERS
	et RPL_NOUSERS sont utilisées. RPL_USERSSTART doit être
	envoyé en premier, suivi par soit une séquence de
	RPL_USERS soit un unique RPL_NOUSER. Enfin, vient un RPL_ENDOFUSERS.
	
	<dl>
	<dt>200     RPL_TRACELINK
	<dd>"Link &lt;version &amp; niveau de débugage&gt; &lt;destination&gt; &lt;serveur suivant&gt;"
	<dt>201     RPL_TRACECONNECTING
	<dd>"Try. &lt;classe&gt; &lt;serveur&gt;"
	<dt>202     RPL_TRACEHANDSHAKE
	<dd>"H.S. &lt;classe&gt; &lt;serveur&gt;"
	<dt>203     RPL_TRACEUNKNOWN
	<dd>"???? &lt;classe&gt; [&lt;adresse IP du client au format utilisant des points&gt;]"
	<dt>204     RPL_TRACEOPERATOR
	<dd>"Oper &lt;classe&gt; &lt;pseudo&gt;"
	<dt>205     RPL_TRACEUSER
	<dd>"User &lt;classe&gt; &lt;pseudo&gt;"
	<dt>206     RPL_TRACESERVER
	<dd>"Serv &lt;classe&gt; &lt;int&gt;S &lt;int&gt;C &lt;serveur&gt; &lt;pseudo!utilisateur|*!*&gt;@&lt;hôte|serveur&gt;"
	<dt>208     RPL_TRACENEWTYPE
	<dd>"&lt;nouveau type&gt; 0 &lt;nom du client&gt;"
	<dt>261     RPL_TRACELOG
	<dd>"File &lt;fichier log&gt; &lt;niveau de débugage&gt;"
	</dl>
	<p>Les RPL_TRACE* sont tous renvoyés par le serveur
	en réponse à un message TRACE. Le nombre de messages
	retournés dépend de la nature du message TRACE,
	et s'il a été envoyé par un opérateur
	ou non. Il n'y a pas d'ordre définissant lequel doit être
	le premier. Les réponses RPL_TRACEUNKNOWN, RPL_TRACECONNECTING
	et RPL_TRACEHANDSHAKE sont toutes utilisées pour des connexions
	qui n'ont pas été complètement établies,
	et sont soit inconnues, soit toujours en cours de connexion,
	soit dans la phase terminale de la 'poignée de main
	du serveur'. RPL_TRACELINK est envoyé par tout serveur
	qui traite un message TRACE et doit le transmettre à un
	autre serveur. La liste de RPL_TRACELINK envoyée en réponse
	à une commande TRACE traversant le réseau IRC devrait
	refléter la connectivité actuelle des serveurs le
	long du chemin. RPL_TRACENEWTYPE est utilisé pour toute
	connexion qui n'entre pas dans les autres catégories,
	mais qui est néanmoins affichée.
	
	<dl>
	<dt>211     RPL_STATSLINKINFO
	<dd>"&lt;nom du lien&gt; &lt;sendq&gt; &lt;messages envoyés&gt; &lt;octets envoyés&gt; &lt;message reçus&gt; &lt;octets reçus&gt; &lt;temps de connexion&gt;"
	<dt>212     RPL_STATSCOMMANDS
	<dd>"&lt;commande&gt; &lt;compteur&gt;"
	<dt>213     RPL_STATSCLINE
	<dd>"C &lt;hôte&gt; * &lt;nom&gt; &lt;port&gt; &lt;classe&gt;"
	<dt>214     RPL_STATSNLINE
	<dd>"N &lt;hôte&gt; * &lt;nom&gt; &lt;port&gt; &lt;classe&gt;"
	<dt>215     RPL_STATSILINE
	<dd>"I &lt;hôte&gt; * &lt;hôte&gt; &lt;port&gt; &lt;classe&gt;"
	<dt>216     RPL_STATSKLINE
	<dd>"K &lt;hôte&gt; * &lt;nom d'utilisateur&gt; &lt;port&gt; &lt;classe&gt;"
	<dt>218     RPL_STATSYLINE
	<dd>"Y &lt;classe&gt; &lt;fréquence des PINGS&gt; &lt;fréquence de connexion&gt; &lt;sendq max&gt;"
	<dt>219     RPL_ENDOFSTATS
	<dd>"&lt;lettre de stats&gt; :End of /STATS report"
	<dt>241     RPL_STATSLLINE
	<dd>"L &lt;masque d'hôte&gt; * &lt;nom de serveur&gt; &lt;profondeur maxi&gt;"
	<dt>242     RPL_STATSUPTIME
	<dd>":Server Up %d days %d:%02d:%02d"
	<dt>243     RPL_STATSOLINE
	<dd>"O &lt;masque d'hôte&gt; * &lt;nom&gt;"
	<dt>244     RPL_STATSHLINE
	<dd>"H &lt;masque d'hôte&gt; * &lt;nom de serveur&gt;"
	</dl>
	<dl>
	<dt>221     RPL_UMODEIS
	<dd>"&lt;chaîne de mode utilisateur&gt;"
	</dl>
	<p>Pour répondre à une requête au
	sujet du mode du client, RPL_UMODEIS est renvoyé.<br>
	
	<dl>
	<dt>251     RPL_LUSERCLIENT
	<dd>":There are &lt;entier&gt; users and &lt;entier&gt; invisible on &lt;entier&gt; servers"
	<dt>252     RPL_LUSEROP
	<dd>"&lt;entier&gt; :operator(s) online"
	<dt>253     RPL_LUSERUNKNOWN
	<dd>"&lt;entier&gt; :unknown connection(s)"
	<dt>254     RPL_LUSERCHANNELS
	<dd>"&lt;entier&gt; :channels formed"
	<dt>255     RPL_LUSERME
	<dd>":I have &lt;entier&gt; clients and &lt;integer&gt; servers"
	</dl>
	<p>Lors du traitement d'un message LUSERS, le serveur
	envoie un lot de réponses parmi RPL_LUSERCLIENT, RPL_LUSEROP,
	RPL_USERUNKNOWN, RPL_LUSERCHANNELS et RPL_LUSERME. Lorsqu'il répond,
	un serveur doit envoyer RPL_LUSERCLIENT et RPL_LUSERME. Les autres
	réponses ne sont renvoyées que si le nombre trouvé
	n'est pas nul.
	
	<dl>
	<dt>256     RPL_ADMINME
	<dd>"&lt;serveur&gt; :Administrative info"
	<dt>257     RPL_ADMINLOC1
	<dd>":&lt;info admin&gt;"
	<dt>258     RPL_ADMINLOC2
	<dd>":&lt;info admin&gt;"
	<dt>259     RPL_ADMINEMAIL
	<dd>":&lt;info admin&gt;"
	</dl>
	<p>Lorsqu'il répond à un message ADMIN,
	un serveur doit renvoyer les réponses RLP_ADMINME à
	RPL_ADMINEMAIL et fournir un texte de message avec chacune. Pour
	RPL_ADMINLOC1, on attend une description de la ville et de l'état
	où se trouve le serveur, suivie des détails de l'université
	et du département (RPL_ADMINLOC2), et finalement le contact
	administratif pour ce serveur (avec obligatoirement une adresse
	email) dans RPL_ADMINEMAIL.
	
	<h2><a name="63">6.3</a> Nombres réservés.</h2>
	
	<p>Ces nombres ne sont pas décrits ci-dessus
	parce qu'ils tombent dans l'une des catégories suivantes :
	<ol>
	<li>Plus utilisés ;
	<li>Réservés à une future utilisation ;
	<li>Utilisés à l'heure actuelle, mais
	faisant partie des caractéristiques non génériques
	des serveurs IRC courants.
	</ol>
	<Pre>        209     RPL_TRACECLASS          217     RPL_STATSQLINE
			231     RPL_SERVICEINFO         232     RPL_ENDOFSERVICES
			233     RPL_SERVICE             234     RPL_SERVLIST
			235     RPL_SERVLISTEND
			316     RPL_WHOISCHANOP         361     RPL_KILLDONE
			362     RPL_CLOSING             363     RPL_CLOSEEND
			373     RPL_INFOSTART           384     RPL_MYPORTIS
			466     ERR_YOUWILLBEBANNED     476     ERR_BADCHANMASK
			492     ERR_NOSERVICEHOST</pre>
	
	<h1><a name="7">7.</a> Authentification des clients et des serveurs</h1>
	
	<p>Les clients et serveurs sont tous deux soumis au
	même niveau d'authentification. Dans les deux cas, une recherche
	du nom d'hôte depuis l'adresse IP (avec vérification
	inverse) est effectuée pour toutes les connexions
	au serveur. Les deux connexions sont alors sujettes à une
	vérification de mot de passe (s'il y a un mot de passe
	défini pour cette connexion). Ces vérifications
	sont possibles pour toutes les connexions, bien que la vérification
	d'un mot de passe ne soit généralement utilisée
	que pour les serveurs.
	<p>
	Une vérification additionnelle de plus en
	plus commune est le nom d'utilisateur à l'origine de la
	connexion. Trouver le nom d'utilisateur à l'origine d'une
	connexion implique typiquement l'utilisation d'un serveur d'authentification
	tel que IDENT, comme il est décrit dans la RFC 1413.
	<p>
	Étant donné qu'il n'est pas facile d'établir
	avec fiabilité qui est à l'autre bout d'une connexion
	réseau, l'utilisation de mots de passe est fortement recommandée
	sur une connexion inter-serveur, en plus des autres mesures telles
	que l'utilisation d'un serveur d'identité.
	
	<h1><a name="8">8.</a> Implémentations actuelles</h1>
	
	<p>La seule implémentation actuelle de ce protocole
	est le serveur IRC version 2.8. Les versions précédentes
	peuvent implémenter certaines ou toutes les commandes décrites
	dans ce document en utilisant les messages NOTICE à la
	place des réponses numériques. Malheureusement,
	à cause des problèmes de compatibilité ascendante,
	les implémentations de certaines parties de ce document
	diffèrent de ce qui est spécifié. Une différence
	notable est :
	<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* La présence de tout LF ou tout CR dans
	le message marque sa fin (au lieu de la séquence
	préconisée CR-LF) ;
	<p>
	Le reste de cette section traite de questions qui sont
	pour la plupart intéressantes pour ceux qui veulent implémenter
	un serveur, mais certaines s'appliquent aussi directement aux
	clients.
	
	<h2><a name="81">8.1</a> Protocole Réseau: TCP - Pourquoi il est le plus approprié.</h2>
	
	<p>IRC a été implémenté
	sur TCP car TCP fournit un protocole réseau fiable qui est
	approprié à cette échelle de discussions. L'utilisation
	d'IP multicast est une alternative, mais n'est pas très
	répandue à l'heure actuelle.
	
	<h3><a name="811">8.1.1</a> Support des sockets Unix</h3>
	
	<p>Etant donné que les domaines de sockets Unix
	permettent les opérations listen/connect, les implémentations
	actuelles peuvent être configurées pour écouter
	et accepter aussi bien les clients que les serveurs sur un domaine
	de socket Unix. On reconnaît les sockets à un nom
	d'hôte commençant par un '/'.
	<p>
	Lors de la communication des informations au sujet
	d'un domaine de socket Unix, le serveur doit remplacer le nom
	de chemin par le vrai nom d'hôte, à moins que le
	vrai nom de socket soit demandé.
	
	<h2><a name="82">8.2</a>  Traitement des commandes</h2>
	
	<p>Afin de fournir des E/S réseaux 'non-tamponnées'
	utiles aux clients et aux serveurs, à chaque connexion
	est associé son propre 'tampon d'entrée' dans lequel
	les résultats de lectures et traitements les plus récents
	sont conservés. Une taille de tampon de 512 octets est utilisée
	afin de contenir un message complet, bien qu'il en contienne habituellement
	plusieurs. Le tampon privé est traité après
	toute opération de lecture à la recherche de messages
	valides. Lors du traitement de messages multiples en provenance
	d'un client, on doit faire attention au cas où un des messages
	causerait le départ du client.
	
	<h2><a name="83">8.3</a>  Distribution de message</h2>
	
	<p>Il est courant de trouver des liens réseaux
	saturés ou des hôtes à qui vous envoyez des
	données et qui sont incapables d'en faire autant. Bien
	qu'Unix gère typiquement cela à travers la fenêtre
	TCP et ses tampons internes, le serveur a généralement
	de grandes quantités de données à envoyer
	(spécialement lorsqu'une nouvelle connexion serveur/serveur
	est créée) et les petits tampons fournis dans le noyau ne
	sont pas suffisants à la queue de sortie. Pour alléger
	ce problème, une "queue d'envoi" est utilisée
	comme une queue FIFO pour les données à envoyer.
	Une "queue d'envoi" typique peut croître jusqu'à
	200ko sur un gros réseau IRC, avec des connexions réseau
	lentes quand un nouveau serveur se connecte.
	<p>
	Lorsqu'il traite ses connexions, un serveur doit
	d'abord lire et traiter toutes les données entrantes, en
	mémorisant les données qui seront émises.
	Quand toutes les entrées disponibles sont traitées,
	la queue d'envoi est expédiée. Cela réduit
	le nombre d'appels systèmes write() et aide TCP à
	faire des paquets plus gros.
	
	<h2><a name="84">8.4</a> La vie d'une connexion</h2>
	
	<p>Pour détecter quand une connexion est morte
	ou ne répond plus, le serveur doit envoyer un PING à
	toutes les connexions dont il n'a pas eu de réponse depuis
	un temps donné.
	<p>
	Si une connexion ne répond pas à temps,
	elle est fermée en utilisant les procédures appropriées.
	Une connexion est également lâchée si son
	sendq grossit au-delà du maximum autorisé, car il
	vaut mieux fermer une connexion lente que d'avoir le processus
	serveur bloqué.
	
	<h2><a name="85">8.5</a> Établissement d'une connexion serveur à client</h2>
	
	<p>Lors de la connexion à un serveur IRC, on
	envoie au client le MOTD (s'il est présent) ainsi que le
	nombre actuel d'utilisateurs et de serveurs (comme pour la commande
	LUSER). Le serveur doit également envoyer un message non
	équivoque au client, qui stipule son nom, sa version, ainsi
	que tout autre message d'introduction qui lui semble approprié.
	
	<p>
	Après cela, le serveur doit envoyer le pseudo
	du nouvel utilisateur, et d'autres informations aussi bien fournies
	par lui-même (commande USER) que découvertes par le
	serveur (de la part des serveurs DNS et IDENT). Le serveur doit envoyer ces informations
	à la première commande NICK suivie de USER.
	
	<h2><a name="86">8.6</a> Établissement d'une connexion serveur/serveur</h2>
	
	<p>Le processus d'établissement d'une connexion
	serveur à serveur est plein de dangers, car il y a de nombreux
	domaines où un problème peut survenir <i>{ - the least
	of which are race conditions.}</i>
	<p>
	Après avoir reçu une connexion suivie
	d'une paire PASS/SERVER qui a été reconnue valide,
	le serveur doit répondre avec ses propres informations
	PASS/SERVER pour cette connexion, ainsi que toutes les informations
	d'état qu'il connaît comme décrit ci-dessous.
	<p>
	Quand le serveur initiant reçoit la paire
	PASS/SERVER, lui aussi vérifie que le serveur répondant
	est authentifié correctement avant d'accepter la connexion
	comme étant ce serveur.
	
	<h3><a name="861">8.6.1</a> Échange des informations d'état des serveurs à la connexion</h3>
	
	<p>L'ordre des informations d'état échangées
	entre les serveurs est essentiel. L'ordre requis est le suivant
	:
	<ul>
	<li>tous les autres serveurs connus ;
	<li>toutes les informations utilisateurs connues ;
	<li>toutes les informations de canaux connues.
	</ul>
	<p>
	Les informations concernant les serveurs sont envoyées
	avec des messages SERVER supplémentaires, les informations
	utilisateurs avec des messages NICK/USER/MODE/JOIN et celles des
	canaux avec des messages MODE.
	<p>
	NOTE : Les sujets des canaux ne sont PAS échangés
	ici, car la commande TOPIC écrase toute information de
	sujet précédente, si bien que, au mieux, les deux
	côtés de la connexion échangeraient les sujets.
	
	<p>
	En passant les informations d'état concernant
	les serveurs en premier, toutes les collisions avec des serveurs
	qui existeraient déjà ont lieu avant les collisions
	de pseudo dues à un second serveur introduisant un pseudonyme
	particulier. En raison de l'obligation de réseau IRC à
	n'exister que sur un graphe acyclique, il est possible que le
	réseau se soit déjà reconnecté ailleurs,
	et l'endroit où la collision a lieu indique où le réseau
	doit être divisé.
	
	<h2><a name="87">8.7</a> Terminaison des connexions serveur/client.</h2>
	
	<p>Lorsqu'une connexion client se ferme, un message
	QUIT est généré de la part du client par
	le serveur sur lequel le client était connecté.
	Aucun autre message ne doit être généré
	ou utilisé.
	
	<h2><a name="88">8.8</a> Terminaison des connexions serveur/serveur.</h2>
	
	<p>Si une connexion serveur/serveur est fermée,
	soit par un SQUIT généré à distance,
	soit par une cause 'naturelle', le reste du réseau IRC
	doit le prendre en compte, et c'est au serveur qui détecte
	la fermeture de faire circuler l'information. Le serveur envoie
	une liste de SQUIT (un par serveur au-delà de la connexion
	coupée) et une liste de QUIT (un par client au-delà
	de la connexion coupée).
	
	<h2><a name="89">8.9</a> Suivi des changements de pseudonymes</h2>
	
	<p>Tous les serveurs IRC doivent garder un historique
	des changements récents de pseudonymes. Cela est nécessaire
	pour offrir au serveur la possibilité de garder le contact
	quand une commande concerne un utilisateur changeant de pseudo.
	Les commandes qui doivent vérifier un changement de pseudo
	sont :
	<ul>
	<li>KILL (le pseudo se faisant tuer)
	<li>MODE (+/- o,v)
	<li>KICK (le pseudo se faisant exclure)
	</ul>
	
	<p>Aucune autre commande ne doit vérifier un
	changement de pseudo.
	<p>
	Dans les cas ci-dessus, le serveur doit tout d'abord
	vérifier l'existence du pseudonyme, puis vérifier
	l'historique pour voir à qui appartient ce pseudo. Cela
	réduit les chances de problèmes, mais ne les empêche
	pas complètement, ce qui peut résulter au final de
	l'affectation du mauvais client. Lors du traçage des changements
	de pseudonymes pour une des commandes ci-dessus, il est recommandé
	qu'un intervalle de temps soit donné, et que les entrées
	trop vieilles soient ignorées.
	<p>
	Pour un historique parfait, un serveur devrait être
	capable de garder les pseudonymes de tous les clients qui ont
	décidé d'un changement. La taille est limitée
	par d'autres facteurs (tels que la mémoire, ...)
	
	<h2><a name="8_10">8.10</a> Contrôle d'inondation des clients</h2>
	
	<p>Dans un gros réseau de serveurs IRC interconnectés,
	il est assez facile, pour un simple client connecté, d'émettre
	un flux continu de messages qui résultent non seulement
	en l'inondation du réseau, mais aussi en la dégradation
	de la qualité de service fournie aux autres clients. Au
	lieu de demander à chaque 'victime' de gérer sa
	propre protection, la protection contre les inondations est incluse
	dans le serveur et est appliquée à tous les clients,
	à l'exception des services. L'algorithme actuel est le
	suivant :
	<ul>
	<li>vérifier si 'l'horodatage du message' du
	client est inférieur à l'heure actuelle (et le mettre à
	l'heure actuelle le cas échéant) ;
	<li>lire toute donnée présentée
	par le client ;
	<li>tant que le compteur est inférieur à
	dix secondes par rapport à l'heure actuelle, traiter tout
	message actuel et pénaliser le client de deux secondes
	par message ;
	</ul>
	
	<p>Ce qui, en essence, signifie qu'un client ne peut
	envoyer plus d'un message toutes les deux secondes sans être
	affecté.
	
	<h2><a name="8_11">8.11</a>  Boucles non bloquantes</h2>
	
	<p>Dans un environnement temps réel, il est essentiel
	qu'un processus serveur attende aussi peu que possible, de manière
	à ce que tous les clients soient servis justement. Évidemment,
	cela nécessite des E/S non bloquantes sur toutes les opérations
	de lecture/écriture du réseau. Pour les connexions
	de serveur normales, ce n'est pas compliqué, mais il y
	a des opérations gérées qui peuvent causer
	un blocage du serveur (telles que les lectures disque). Quand
	c'est possible, de telles activités doivent être
	exécutées avec un délai d'attente maximal
	court.
	
	<h3><a name="8_11_1">8.11.1</a> Recherche du nom d'hôte (DNS)</h3>
	
	<p>L'utilisation des librairies de résolution
	standards de Berkeley et autres entraîne de gros délais,
	dans les cas où les réponses n'arrivent pas. Afin
	d'éviter cela, un jeu de routines DNS indépendantes
	ont été écrites, où les opérations
	DNS ont été écrites avec des E/S non bloquantes
	et testées depuis la boucle d'E/S principale du serveur.
	
	<h3><a name="8_11_2">8.11.2</a> Recherche du nom d'utilisateur (IDENT)</h3>
	
	<p>Bien qu'il y ait de nombreuses librairies IDENT à
	utiliser et inclure dans d'autres programmes, elles posent des
	problèmes puisqu'elles opèrent de façon synchrone,
	et résultent en de nombreuses attentes. Encore une fois,
	la solution a été d'écrire un jeu de routines
	qui coopèrent avec le reste du serveur, et utilisent des
	E/S non bloquantes.
	
	<h2><a name="8_12">8.12</a> Fichier de configuration</h2>
	
	<p>Afin de fournir une façon flexible de configurer
	et de lancer le serveur, il est recommandé qu'un fichier
	de configuration soit utilisé, qu'il contienne les instructions
	du serveur suivantes :
	<ul>
	<li>de quels hôtes accepter une connexion en
	tant que client;
	
	<li>de quels hôtes accepter une connexion en
	tant que serveur;
	
	<li>à quels hôtes se connecter (aussi
	bien activement que passivement) ;
	
	<li>informations sur l'emplacement du serveur (université,
	ville/état, entreprise par exemple) ;
	
	<li>quels sont les responsables du serveur, avec une
	adresse email où ils peuvent être contactés ;
	
	<li>noms d'hôtes et mots de passe pour les clients
	qui souhaitent obtenir l'accès restreint aux commandes
	d'opérateur.
	
	</ul>
	
	<p>Lors de la spécification des noms d'hôtes,
	les noms de domaines et la notation 'point' (127.0.0.1) doivent
	être tous les deux gérés. Il doit être
	possible de préciser un mot de passe à utiliser/accepter
	pour toutes les connexions entrantes et sortantes (bien que les
	connexions sortantes soient toutes à destination de serveurs).
	
	<p>
	La liste ci-dessus est le minimum obligatoire pour
	tout serveur qui souhaite se connecter à un autre serveur.
	Parmi les autres éléments utiles, on trouve :
	<ul>
	<li>spécification de quels serveurs un serveur
	peut introduire ;
	
	<li>jusqu'à quelle longueur une branche de serveur
	peut aller ;
	
	<li>heures durant lesquelles un client peut se connecter
	</ul>
	
	
	<h3><a name="8_12_1">8.12.1</a> Autorisation des connexions de clients</h3>
	
	<p>Un serveur doit utiliser une sorte de 'liste de contrôle
	d'accès' (soit dans le fichier de configuration ou ailleurs)
	qu'il lit au démarrage et utilise pour décider quels
	hôtes les clients peuvent utiliser pour se connecter.
	<p>
	'Accepter' et 'interdire' doivent tous deux être
	implémentés pour fournir le niveau de flexibilité
	requis par le contrôle d'accès des hôtes.
	
	<h3><a name="8_12_2">8.12.2</a> Opérateurs</h3>
	
	<p>En raison des pouvoirs qui leur sont accordés,
	le don des privilèges d'opérateur à une
	personne turbulente peut avoir des conséquences désastreuses
	sur le bien-être du réseau IRC en général.
	C'est pourquoi l'acquisition de ces pouvoirs ne doit pas être
	facile. La configuration actuelle nécessite deux mots de
	passes, bien que l'un d'entre eux soit généralement
	facile à trouver. L'enregistrement des mots de passe d'opérateur
	dans le fichier de configuration est préférable
	à leur codage en dur, et ils doivent être sauvegardés
	dans un format codé (par exemple en utilisant crypt(3)
	d'Unix) afin de rendre les vols plus difficiles.
	
	<h3><a name="8_12_3">8.12.3</a> Autorisation des connexions de serveurs</h3>
	
	<p>L'interconnexion de serveurs n'est pas une chose
	triviale : une mauvaise connexion peut avoir un gros impact sur
	l'utilité d'IRC. C'est pourquoi chaque serveur doit avoir
	une liste des serveurs sur lesquels il peut se connecter, et de
	ceux qui peuvent se connecter à lui. En aucune manière
	un serveur ne doit accepter qu'un hôte arbitraire se connecte
	en tant que serveur. En plus de la liste des serveurs qui peuvent
	et qui ne peuvent pas se connecter, le fichier de configuration
	doit aussi contenir le mot de passe et les autres caractéristiques
	de ce lien.
	
	<h3><a name="8_12_4">8.12.4</a> Admin</h3>
	
	<p>Pour fournir des réponses valides et précises
	à la commande ADMIN (voir section <a href="#437">4.3.7</a>), le serveur doit
	trouver tous les détails appropriés dans le fichier
	de configuration.
	
	<h2><a name="8_13">8.13</a> Appartenance à un canal.</h2>
	
	<p>Le serveur actuel autorise tout utilisateur enregistré
	localement à accéder jusqu'à 10 canaux différents.
	Il n'y a pas de limites imposées aux utilisateurs non-locaux,
	si bien que le serveur reste (raisonnablement) cohérent
	avec les autres serveurs pour ce qui est de l'appartenance à
	un canal.
	
	<h1><a name="9">9.</a> Problèmes actuels</h1>
	
	<p>Il y a nombre de problèmes reconnus avec ce
	protocole, chacun d'entre eux espérant être résolu
	dans un futur proche lors de sa réécriture. Actuellement,
	le travail est en cours pour trouver des solutions convenables
	à ces problèmes.
	
	<h2><a name="91">9.1</a> Localisation</h2>
	
	<p>Il est largement reconnu que ce protocole ne gère
	pas correctement les localisations lorsqu'il est utilisé
	dans une grande arène. Le problème principal vient
	de la nécessité qu'ont tous les serveurs de connaître
	tous les autres serveurs et utilisateurs, et que leurs informations
	soient mises à jour dès que possible. Il est aussi
	nécessaire de garder un faible nombre de serveurs, de façon
	à ce que le chemin entre deux points reste aussi faible
	que possible, et que l'arbre de distribution contienne des branches
	aussi grosses que possible.
	
	<h2><a name="92">9.2</a> Identifiants</h2>
	
	<p>Le protocole IRC courant a trois types d'identifiants
	: le pseudonyme, le nom de canal, et le nom de serveur. Chacun
	de ses trois types a son propre domaine, et aucun doublon n'est
	autorisé dans ce domaine. Actuellement, il est possible
	pour un utilisateur de prendre l'identifiant pour n'importe
	laquelle des trois, ce qui résulte en une collision. Il
	est largement reconnu que cela nécessite des modifications,
	et le plan actuel prévoit des noms uniques pour que les canaux
	et les pseudo n'entrent pas en collision, ainsi qu'une solution
	autorisant un arbre cyclique.
	
	<h3><a name="921">9.2.1</a> Pseudonymes</h3>
	
	<p>L'idée de pseudonymes sur IRC est très
	pratique pour les utilisateurs qui parlent hors des canaux, mais
	il y a un nombre fini des pseudonymes, et il n'est pas rare de
	voir plusieurs personne vouloir utiliser le même pseudo.
	Si un pseudonyme est choisi par deux personnes qui utilisent ce
	protocole, soit l'une des deux ne réussit pas à l'obtenir,
	soit toutes les deux sont déconnectées par l'utilisation
	de KILL (4.6.1).
	
	<h3><a name="922">9.2.2</a> Canaux</h3>
	
	<p>La configuration actuelle des canaux nécessite que
	tous les serveurs connaissent tous les canaux, leurs membres,
	et leurs propriétés. En plus du dimensionnement inadapté, la
	confidentialité pose problème aussi. La collision de canaux est gérée
	de façon inclusive (les deux personnes qui créent
	le canal sont considérées comme en étant membres)
	plutôt que de façon exclusive telle que celle utilisée
	pour résoudre les collisions de pseudonymes.
	
	<h3><a name="923">9.2.3</a> Serveurs</h3>
	
	<p>Bien que le nombre de serveurs soit habituellement
	petit comparé au nombre d'utilisateurs et de canaux, ils
	doivent aussi être connus globalement, soit chacun séparément,
	soit caché derrière un masque.
	
	<h2><a name="93">9.3</a> Algorithmes</h2>
	
	<p>À certains endroits du code du serveur, il n'a pas
	été possible d'éviter des algorithmes N^2,
	comme par exemple dans la vérification de la liste des
	canaux d'un ensemble de clients.
	<p>
	Dans les versions actuelles du serveur, il n'y a
	pas vérification de base de données, chaque serveur
	assumant qu'un serveur voisin est correct. Cela ouvre la porte
	à de gros problèmes si un serveur qui se connecte
	est bogué ou essaie d'introduire des contradictions dans
	le réseau existant.
	<p>
	Actuellement, en raison du manque d'étiquettes
	internes et globales uniques, il existe une multitude de conditions
	pouvant causer une désynchronisation. Ces conditions résultent
	généralement du temps pris par un message pour traverser
	le réseau IRC. Mais, même en changeant pour des étiquettes
	uniques, il y a des problèmes de synchronisation avec les
	commandes liées aux canaux.
	
	<h1><a name="_10">10.</a> Support actuel et disponibilité</h1>
	
	<ul>
	<li>Mailing lists pour les discussions liées à l'IRC :
		<ul>
		<li>Protocole futur : ircd-three-request@eff.org
		<li>Discussion générale: operlist-request@eff.org
		</ul>
	
	<li>Implémentations logicielles
		<ul>
		<li>cs.bu.edu:/irc
		<li>nic.funet.fi:/pub/irc
		<li>coombs.anu.edu.au:/pub/irc<br>
		</ul>
	<li>Newsgroup: alt.irc<br>
	</ul>
	
	<h1><a name="_11">11.</a> Considérations de sécurité</h1>
	<p> La sécurité est traitée dans
	les sections <a href="#41">4.1</a>, <a href="#411">4.1.1</a>, <a href="#413">4.1.3</a>,
	<a href="#55">5.5</a>, et <a href="#7">7</a>.<br>
	
	<h1><a name="_12">12.</a> Adresses des auteurs</h1>
	
	<p>
	   Jarkko Oikarinen
	<br>
	   Tuirantie 17 as 9
	<br>
	   90500 OULU
	<br>
	   FINLAND
	<br>
	   Email: <a href="mailto:jto@tolsun.oulu.fi">jto@tolsun.oulu.fi</a>
	
	<p>
	   Darren Reed
	<br>
	   4 Pateman Street
	<br>
	   Watsonia, Victoria 3087
	<br>
	   Australia
	<br>
	   Email: <a href="mailto:avalon@coombs.anu.edu.au">avalon@coombs.anu.edu.au</a>
	
	<p>
	   Traduit de l'anglais par JM "Nirgal" Vourgère
	
	<!--- increment the counter--->
	</div>
	
	</div class=main></body>
	</html>
	